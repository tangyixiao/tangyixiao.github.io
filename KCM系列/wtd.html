<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‡»è´¥WTD - è¶…å¼ºè¿›åŒ–</title>
    <style>
        /* ----- æ‰€æœ‰åŸæœ‰æ ·å¼å®Œæ•´ä¿ç•™ï¼Œå¹¶æ–°å¢Wild flowerç›¸å…³åŠ¨æ€æ•ˆæœå·²åœ¨Canvasä¸­å®ç° ----- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #000000, #200050, #4000a0);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(150, 0, 255, 0.8);
            border: 4px solid #ff00ff;
            max-width: 1100px;
            width: 100%;
            backdrop-filter: blur(10px);
        }
        
        .game-title {
            color: #ff00ff;
            font-size: 4rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 0, 255, 1);
            letter-spacing: 4px;
            background: linear-gradient(to right, #ff00ff, #00ffff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s infinite alternate;
        }
        
        @keyframes titleGlow {
            0% { text-shadow: 0 0 10px rgba(255, 0, 255, 0.8), 0 0 20px rgba(255, 0, 255, 0.6); }
            100% { text-shadow: 0 0 20px rgba(255, 0, 255, 1), 0 0 30px rgba(255, 0, 255, 0.8), 0 0 40px rgba(255, 0, 255, 0.6); }
        }
        
        .subtitle {
            font-size: 1.5rem;
            color: #a0a0ff;
            margin-bottom: 15px;
        }
        
        .game-container {
            position: relative;
            width: 1100px;
            height: 700px;
            background-color: rgba(0, 0, 0, 0.95);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(150, 0, 255, 0.8);
            border: 4px solid #ff00ff;
            margin-bottom: 20px;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
        }
        
        .hud {
            display: grid;
            grid-template-columns: repeat(5, 1fr) 3fr;
            gap: 15px;
            width: 1100px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(150, 0, 255, 0.6);
            border: 3px solid #ff00ff;
        }
        
        .hud-item {
            text-align: center;
            padding: 10px;
            background: rgba(30, 0, 60, 0.9);
            border-radius: 10px;
            border: 2px solid #7a2fff;
        }
        
        .hud-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.9);
            margin-bottom: 5px;
            animation: valuePulse 2s infinite;
        }
        
        @keyframes valuePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .hud-label {
            font-size: 1.1rem;
            color: #a0a0ff;
        }
        
        .ability-bar {
            grid-column: 6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ability {
            width: 70px;
            height: 70px;
            border-radius: 15px;
            background: rgba(50, 20, 80, 0.9);
            border: 3px solid #ff00ff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .ability:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.9);
        }
        
        .ability:active {
            transform: scale(0.95);
        }
        
        .ability-icon {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }
        
        .ability-key {
            font-size: 0.9rem;
            color: #ffff00;
            background: rgba(0, 0, 0, 0.7);
            padding: 3px 6px;
            border-radius: 5px;
        }
        
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 0, 0, 0.8);
            transition: height 0.3s;
        }
        
        .auto-toggle {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #555;
            border: 2px solid #fff;
            cursor: pointer;
        }
        
        .auto-toggle.active {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .controls {
            width: 1100px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 16px 32px;
            font-size: 1.3rem;
            background: linear-gradient(to bottom, #ff00ff, #aa00ff);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.3);
            flex: 1;
            min-width: 160px;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .btn:hover {
            background: linear-gradient(to bottom, #ff33ff, #cc33ff);
            transform: translateY(-4px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        #start-btn {
            background: linear-gradient(to bottom, #00ff88, #00cc66);
        }
        
        #start-btn:hover {
            background: linear-gradient(to bottom, #33ffaa, #33ff88);
        }
        
        #upgrade-btn {
            background: linear-gradient(to bottom, #ffff00, #ffaa00);
        }
        
        #upgrade-btn:hover {
            background: linear-gradient(to bottom, #ffff33, #ffcc33);
        }
        
        .instructions {
            width: 1100px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            padding: 20px;
            margin-top: 10px;
            border: 3px solid #ff00ff;
            box-shadow: 0 0 25px rgba(150, 0, 255, 0.6);
        }
        
        .instructions h2 {
            color: #ff00ff;
            margin-bottom: 15px;
            font-size: 2rem;
            text-shadow: 0 0 15px rgba(255, 0, 255, 0.7);
        }
        
        .instructions-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .instructions-section {
            background: rgba(30, 0, 60, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #7a2fff;
        }
        
        .instructions-section h3 {
            color: #00ffff;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }
        
        .instructions-section ul {
            list-style-type: none;
            padding-left: 10px;
        }
        
        .instructions-section li {
            margin-bottom: 8px;
            color: #a0a0ff;
            padding-left: 20px;
            position: relative;
        }
        
        .instructions-section li:before {
            content: "âš¡";
            color: #ff00ff;
            font-size: 1rem;
            position: absolute;
            left: 0;
            top: 0;
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .game-over h2 {
            font-size: 5rem;
            color: #ff5555;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 85, 85, 1);
            animation: gameOverPulse 1.5s infinite;
        }
        
        @keyframes gameOverPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .game-over p {
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: #00ffaa;
            text-shadow: 0 0 15px rgba(0, 255, 170, 0.9);
        }
        
        .mobile-controls {
            display: none;
            width: 100%;
            margin-top: 20px;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        
        .mobile-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 0, 255, 0.8);
            color: white;
            font-size: 28px;
            border: 4px solid rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            margin: 5px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }
        
        .mobile-shoot {
            background: rgba(0, 255, 255, 0.8);
        }
        
        .mobile-ability {
            background: rgba(255, 255, 0, 0.8);
            font-size: 22px;
        }
        
        .boss-health {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 35px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #ff5555;
            border-radius: 20px;
            overflow: hidden;
            z-index: 10;
            display: none;
        }
        
        .boss-health-bar {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff5555, #ff8888);
            width: 100%;
            transition: width 0.5s;
        }
        
        .boss-health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            font-size: 1.2rem;
        }
        
        .powerup-indicator {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 10px 20px;
            display: none;
            z-index: 10;
            color: #00ffff;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
        }
        
        @media (max-width: 1150px) {
            .game-container, .hud, .controls, .instructions {
                width: 95vw;
            }
            
            .game-container {
                height: 70vh;
            }
            
            .game-title {
                font-size: 3rem;
            }
            
            .ability-bar {
                grid-column: 1 / span 6;
                grid-row: 2;
                margin-top: 10px;
            }
            
            .hud {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .mobile-controls {
                display: flex;
            }
        }
        
        @media (max-width: 750px) {
            .instructions-content {
                grid-template-columns: 1fr;
            }
            
            .hud {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .btn {
                min-width: 140px;
                font-size: 1.1rem;
                padding: 14px 20px;
            }
        }
        
        .auto-toggle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            color: #a0a0ff;
            font-size: 0.9rem;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-left: 10px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: .4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #00ff00;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        /* å¤©èµ‹å‡çº§æç¤º */
        .upgrade-notification {
            position: absolute;
            top: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ffff00;
            border-radius: 15px;
            padding: 25px;
            z-index: 80;
            color: #ffff00;
            text-align: center;
            min-width: 400px;
            display: none;
            box-shadow: 0 0 30px rgba(255, 255, 0, 0.7);
            backdrop-filter: blur(10px);
        }
        
        .upgrade-notification h3 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            text-shadow: 0 0 15px rgba(255, 255, 0, 0.9);
        }
        
        .upgrade-notification p {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #00ffff;
        }
        
        .upgrade-notification .upgrade-effect {
            font-size: 1.2rem;
            color: #a0a0ff;
            margin-bottom: 25px;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">å‡»è´¥WTD - è¶…å¼ºè¿›åŒ–</h1>
        <p class="subtitle">æè‡´å¼¹å¹•ä½“éªŒï¼æ–°å¢ç¬¬5Bossï¼šWild flowerğŸŒ¸ ä¸‰è§’å½¢å°–åˆºï¼</p>
    </div>
    
    <div class="hud">
        <div class="hud-item">
            <div class="hud-label">å¾—åˆ†</div>
            <div id="score" class="hud-value">0</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">ç”Ÿå‘½å€¼</div>
            <div id="health" class="hud-value">200</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">ç­‰çº§</div>
            <div id="level" class="hud-value">1</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">è¿å‡»</div>
            <div id="combo" class="hud-value">0</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">æ”»å‡»åŠ›</div>
            <div id="damage-value" class="hud-value">50</div>
        </div>
        
        <div class="ability-bar">
            <div class="ability" id="ability1" data-key="Q">
                <div class="ability-icon">âš¡</div>
                <div class="ability-key">Q</div>
                <div class="auto-toggle active" id="auto-toggle-1"></div>
                <div class="ability-cooldown" id="cooldown1"></div>
            </div>
            <div class="ability" id="ability2" data-key="W">
                <div class="ability-icon">ğŸ›¡ï¸</div>
                <div class="ability-key">W</div>
                <div class="auto-toggle active" id="auto-toggle-2"></div>
                <div class="ability-cooldown" id="cooldown2"></div>
            </div>
            <div class="ability" id="ability3" data-key="E">
                <div class="ability-icon">ğŸ’£</div>
                <div class="ability-key">E</div>
                <div class="auto-toggle active" id="auto-toggle-3"></div>
                <div class="ability-cooldown" id="cooldown3"></div>
            </div>
            <div class="ability" id="ability4" data-key="R">
                <div class="ability-icon">ğŸŒŸ</div>
                <div class="ability-key">R</div>
                <div class="auto-toggle active" id="auto-toggle-4"></div>
                <div class="ability-cooldown" id="cooldown4"></div>
            </div>
            <div class="ability" id="ability5" data-key="T">
                <div class="ability-icon">ğŸŒ€</div>
                <div class="ability-key">T</div>
                <div class="auto-toggle active" id="auto-toggle-5"></div>
                <div class="ability-cooldown" id="cooldown5"></div>
            </div>
        </div>
    </div>
    
    <div class="game-container">
        <div class="boss-health" id="boss-health">
            <div class="boss-health-bar" id="boss-health-bar"></div>
            <div class="boss-health-text" id="boss-health-text">WTD BOSS: 100%</div>
        </div>
        
        <div class="powerup-indicator" id="powerup-indicator">
            æ”»å‡»åŠ›æå‡ï¼
        </div>
        
        <!-- å¤©èµ‹å‡çº§æç¤º -->
        <!-- å¤©èµ‹å‡çº§æç¤º - ç§»é™¤ç¡®è®¤æŒ‰é’® -->
<div class="upgrade-notification" id="upgrade-notification">
    <h3>ğŸ‰ ç­‰çº§æå‡ï¼</h3>
    <p id="upgrade-title">è·å¾—æ–°å¤©èµ‹</p>
    <div class="upgrade-effect" id="upgrade-effect">å¤©èµ‹æ•ˆæœæè¿°</div>
    <!-- æŒ‰é’®å·²ç§»é™¤ï¼Œ2ç§’åè‡ªåŠ¨æ¶ˆå¤± -->
</div>
        
        <canvas id="game-canvas" width="1100" height="700"></canvas>
        
        <div class="game-over" id="game-over">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <p id="final-score">å¾—åˆ†: 0</p>
            <p id="final-level">ç­‰çº§: 1</p>
            <p id="final-combo">æœ€é«˜è¿å‡»: 0</p>
            <button class="btn" id="restart-btn">é‡æ–°å¼€å§‹</button>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn" id="start-btn">å¼€å§‹æ¸¸æˆ</button>
        <button class="btn" id="pause-btn">æš‚åœæ¸¸æˆ</button>
        <button class="btn" id="instructions-btn">æ¸¸æˆè¯´æ˜</button>
        <button class="btn" id="godmode-btn">ä¸Šå¸æ¨¡å¼</button>
    </div>
    
    <div class="mobile-controls">
        <div class="mobile-btn" id="mobile-left">â†</div>
        <div class="mobile-btn" id="mobile-up">â†‘</div>
        <div class="mobile-btn" id="mobile-down">â†“</div>
        <div class="mobile-btn" id="mobile-right">â†’</div>
        <div class="mobile-btn mobile-shoot" id="mobile-shoot">âš¡</div>
        <div class="mobile-btn mobile-ability" id="mobile-ability1">Q</div>
        <div class="mobile-btn mobile-ability" id="mobile-ability2">W</div>
        <div class="mobile-btn mobile-ability" id="mobile-ability3">E</div>
    </div>
    
    <div class="instructions" id="instructions-panel" style="display: none;">
        <h2>æ¸¸æˆè¯´æ˜ - è¶…å¼ºè¿›åŒ–ç‰ˆ</h2>
        <div class="instructions-content">
            <div class="instructions-section">
                <h3>è¶…å¼ºåˆå§‹å±æ€§</h3>
                <ul>
                    <li>åˆå§‹ç”Ÿå‘½å€¼ï¼š200ï¼ˆåŸ100ï¼‰</li>
                    <li>åˆå§‹æ”»å‡»åŠ›ï¼š50ï¼ˆåŸ10ï¼‰</li>
                    <li>åˆå§‹å°„é€Ÿï¼šæ¯ç§’10å‘ï¼ˆåŸ5å‘ï¼‰</li>
                    <li>åˆå§‹ç§»åŠ¨é€Ÿåº¦ï¼š8ï¼ˆåŸ5ï¼‰</li>
                    <li>ä¸‰è¿å‘å­å¼¹ï¼Œè‡ªåŠ¨ç„å‡†</li>
                    <li>è¿ç»­å‡»ä¸­æ•Œäººå¢åŠ è¿å‡»ï¼Œæå‡æ”»å‡»åŠ›</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>æŠ€èƒ½ç³»ç»Ÿï¼ˆé»˜è®¤è‡ªåŠ¨é‡Šæ”¾ï¼‰</h3>
                <ul>
                    <li>Qé”®ï¼šè¶…ç”µç£ç‚® - æ•Œäººâ‰¥3æ—¶é‡Šæ”¾ï¼Œè¿é”æ”»å‡»</li>
                    <li>Wé”®ï¼šç»å¯¹é˜²å¾¡ - ç”Ÿå‘½å€¼<50%æ—¶é‡Šæ”¾ï¼Œæ— æ•Œ4ç§’</li>
                    <li>Eé”®ï¼šé»‘æ´ç‚¸å¼¹ - æ•Œäººâ‰¥5æ—¶é‡Šæ”¾ï¼Œå¸èšæ•Œäºº</li>
                    <li>Ré”®ï¼šæµ®æ¸¸ç‚® - æ— æ— äººæœºæ—¶é‡Šæ”¾ï¼Œå¬å”¤4ä¸ªæµ®æ¸¸ç‚®</li>
                    <li>Té”®ï¼šæ—¶é—´åœæ» - å­å¼¹â‰¥20æ—¶é‡Šæ”¾ï¼Œå†»ç»“3ç§’</li>
                    <li>æ‰€æœ‰æŠ€èƒ½é»˜è®¤è‡ªåŠ¨é‡Šæ”¾ï¼Œå¯æ‰‹åŠ¨åˆ‡æ¢</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>å¼ºåŒ–æ•Œäººç³»ç»Ÿ</h3>
                <ul>
                    <li>æ™®é€šWTDï¼šç”Ÿå‘½å€¼500ï¼Œé€Ÿåº¦æ›´å¿«</li>
                    <li>é—ªç”µWTDï¼šè¶…é«˜é€Ÿåº¦ï¼Œæ®‹å½±æ•ˆæœ</li>
                    <li>é‡ç”²WTDï¼šç”Ÿå‘½å€¼1500ï¼Œå‡ä¼¤50%</li>
                    <li>ç‹™å‡»WTDï¼šè¶…è¿œè·ç¦»ç²¾å‡†å°„å‡»</li>
                    <li>å¬å”¤WTDï¼šå¬å”¤æ›´å¤šWTD</li>
                    <li>Gay0ï¼šå½©è™¹è¿½è¸ªå­å¼¹ï¼Œä¸­ç­‰ç”Ÿå‘½å€¼</li>
                    <li>Sigmaï¼šæ¿€å…‰åˆ†è£‚æ”»å‡»ï¼Œé«˜ç§‘æŠ€æ•Œäºº</li>
                    <li>gqhå­¦å§ï¼šè¶…é«˜ç”Ÿå‘½å€¼ï¼Œä¸­ç­‰é€Ÿåº¦</li>
                    <li>WTD BOSSï¼šå¤šé‡æ”»å‡»æ¨¡å¼ï¼Œå¤šç§å¼¹å¹•</li>
                    <li style="color: #ff69b4; font-weight: bold;">âœ¨ Wild flowerğŸŒ¸ï¼šç¬¬5ä¸ªBossï¼Œè¶…å¼ºç”Ÿå‘½å€¼ï¼Œå¿«é€Ÿå‘å°„ä¸‰è§’å½¢å°–åˆºï¼</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>éšæœºå‡çº§ç³»ç»Ÿ</h3>
                <ul>
                    <li>æ¯æ¬¡å‡çº§éšæœºè·å¾—ä¸€ä¸ªå¤©èµ‹</li>
                    <li>å¤©èµ‹æ•ˆæœç«‹å³ç”Ÿæ•ˆ</li>
                    <li>æ˜¾ç¤ºå¤©èµ‹åŠ æˆæç¤º</li>
                    <li>å‡çº§æ•ˆæœå¤§å¹…å¢å¼ºï¼Œæ€§ä»·æ¯”æ›´é«˜</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // ==================== è·å–Canvaså’Œä¸Šä¸‹æ–‡ ====================
const bossImage = new Image();
bossImage.src = 'https://cdn.luogu.com.cn/upload/image_hosting/ug4sjv38.png';
const shadowTImage = new Image();
shadowTImage.src = 'https://cdn.luogu.com.cn/upload/image_hosting/gcrsj6dz.png';
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameRunning = false;
        let gamePaused = false;
        let gameLoop;
        let score = 0;
        let health = 200;
        let maxHealth = 200;
        let playerLevel = 1;
        let xp = 0;
        let xpToNextLevel = 100;
        let wave = 1;
        let enemiesRemaining = 0;
        let bossActive = false;
        let godMode = false;
        let combo = 0;
        let maxCombo = 0;
        let comboTimeout = null;
        let frenzyMode = false;
        let autoSkills = true;

        // ========== æ–°å¢ï¼šè®°å½•Bossç”Ÿæˆæ¬¡æ•°ï¼Œç”¨äºç¬¬5ä¸ªBosså˜ä¸ºWild flowerğŸŒ¸ ==========
        let bossSpawnCount = 0;
        
        // ==================== ç©å®¶å±æ€§ ====================
        const player = {
            x: canvas.width / 2 - 25,
            y: canvas.height / 2 - 25,
            width: 50,
            height: 50,
            speed: 8,
            color: '#00a8ff',
            bullets: [],
            lastShot: 0,
            shotDelay: 100,
            damage: 50,
            pierce: 0,
            explosive: false,
            tripleShot: true,
            homing: false,
            attackRange: 1.0,
            bulletCount: 1,
            regenHealth: false,
            regenRate: 0,
            dodgeChance: 0
        };
        
        // ==================== å‡çº§ç³»ç»Ÿ ====================
        const upgrades = {
            damage: { level: 1, cost: 100, name: "æ¯ç­æ”»å‡»", effect: "å¢åŠ å­å¼¹ä¼¤å®³100%ï¼Œæ”»å‡»èŒƒå›´æ‰©å¤§" },
            fireRate: { level: 1, cost: 100, name: "æé™å°„é€Ÿ", effect: "å¢åŠ å°„å‡»é€Ÿåº¦150%ï¼Œå¯åŒæ—¶å‘å°„å¤šé¢—å­å¼¹" },
            health: { level: 1, cost: 100, name: "æ— æ•Œä¹‹èº¯", effect: "å¢åŠ æœ€å¤§ç”Ÿå‘½å€¼20%å¹¶å›æ»¡ç”Ÿå‘½" },
            speed: { level: 1, cost: 100, name: "å…‰é€Ÿç§»åŠ¨", effect: "å¢åŠ ç§»åŠ¨é€Ÿåº¦100%ï¼Œå¢åŠ é—ªé¿å‡ ç‡" },
            pierce: { level: 0, cost: 300, name: "æ— é™ç©¿é€", effect: "å­å¼¹å¯ä»¥æ— é™ç©¿é€æ•Œäººï¼Œä¼¤å®³ä¸è¡°å‡" },
            explosive: { level: 0, cost: 500, name: "æ ¸çˆ†å­å¼¹", effect: "å­å¼¹å‡»ä¸­æ—¶äº§ç”Ÿå¤§èŒƒå›´çˆ†ç‚¸ï¼Œè¿é”ååº”" },
            critical: { level: 0, cost: 400, name: "è‡´å‘½ä¸€å‡»", effect: "å¢åŠ æš´å‡»å‡ ç‡25%ï¼Œæš´å‡»ä¼¤å®³æå‡300%" },
            vampire: { level: 0, cost: 350, name: "å¸è¡€æ”»å‡»", effect: "é€ æˆä¼¤å®³çš„10%è½¬åŒ–ä¸ºç”Ÿå‘½å€¼" }
        };
        
        // æš´å‡»ç³»ç»Ÿ
        let criticalChance = 0;
        let criticalMultiplier = 2.0;
        
        // å¸è¡€ç³»ç»Ÿ
        let vampiricRatio = 0;
        
        // ==================== æŠ€èƒ½ç³»ç»Ÿ ====================
        const abilities = {
            chainLightning: {
                name: "è¶…ç”µç£ç‚®", key: "Q", cooldown: 8000, lastUsed: 0, active: false, auto: true
            },
            shield: {
                name: "ç»å¯¹é˜²å¾¡", key: "W", cooldown: 12000, lastUsed: 0, active: false, duration: 4000, auto: true
            },
            bomb: {
                name: "é»‘æ´ç‚¸å¼¹", key: "E", cooldown: 15000, lastUsed: 0, active: false, auto: true
            },
            drone: {
                name: "æµ®æ¸¸ç‚®", key: "R", cooldown: 20000, lastUsed: 0, active: false, drones: [], auto: true
            },
            timeStop: {
                name: "æ—¶é—´åœæ»", key: "T", cooldown: 25000, lastUsed: 0, active: false, duration: 3000, auto: true
            }
        };
        
        // æ—¶é—´åœæ»
        let timeStopActive = false;
        let timeStopEnd = 0;
        
        // æ•Œäººæ•°ç»„
        let enemies = [];
        // Bosså¯¹è±¡
        let boss = null;
        // ç²’å­æ•°ç»„
        let particles = [];
        // æ•Œäººå­å¼¹æ•°ç»„
        let enemyBullets = [];
        
        // æ§åˆ¶çŠ¶æ€
        const keys = {};
        const mouse = { x: 0, y: 0, pressed: false };
        
        // ==================== åˆå§‹åŒ–æ¸¸æˆ ====================
        function initGame() {
            score = 0;
            health = maxHealth;
            playerLevel = 1;
            xp = 0;
            xpToNextLevel = 100;
            wave = 1;
            enemiesRemaining = 0;
            bossActive = false;
            combo = 0;
            maxCombo = 0;
            frenzyMode = false;
            timeStopActive = false;
            criticalChance = 0;
            criticalMultiplier = 2.0;
            vampiricRatio = 0;
            
            // é‡ç½®Bossç”Ÿæˆè®¡æ•°
            bossSpawnCount = 0;
            
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height / 2 - 25;
            player.bullets = [];
            player.lastShot = 0;
            player.speed = 8;
            player.damage = 50;
            player.pierce = 0;
            player.explosive = false;
            player.tripleShot = true;
            player.homing = false;
            player.attackRange = 1.0;
            player.bulletCount = 1;
            player.regenHealth = false;
            player.regenRate = 0;
            player.dodgeChance = 0;

player.damage = 40;
player.shotDelay = 30;
player.Health=200;
player.maxHealth=200;
            
            upgrades.damage.level = 1;
            upgrades.fireRate.level = 1;
            upgrades.health.level = 1;
            upgrades.speed.level = 1;
            upgrades.pierce.level = 0;
            upgrades.explosive.level = 0;
            upgrades.critical.level = 0;
            upgrades.vampire.level = 0;
            
            for (let ability in abilities) {
                abilities[ability].lastUsed = 0;
                abilities[ability].active = false;
                abilities[ability].auto = true;
                if (abilities[ability].drones) abilities[ability].drones = [];
            }
            
            enemies = [];
            particles = [];
            enemyBullets = [];
            boss = null;
            
            updateUI();
            
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('upgrade-notification').style.display = 'none';
            document.getElementById('boss-health').style.display = 'none';
            document.getElementById('powerup-indicator').style.display = 'none';
            
            spawnWave();
        }
        
        // ==================== å¼€å§‹æ¸¸æˆ ====================
        function startGame() {
            if (gameRunning) return;
            initGame();
            gameRunning = true;
            gamePaused = false;
            gameLoop = requestAnimationFrame(updateGame);
            document.getElementById('start-btn').textContent = 'æ¸¸æˆä¸­...';
            document.getElementById('pause-btn').textContent = 'æš‚åœæ¸¸æˆ';
        }
        
        // ==================== æš‚åœæ¸¸æˆ ====================
        function pauseGame() {
            if (!gameRunning) return;
            gamePaused = !gamePaused;
            if (gamePaused) {
                cancelAnimationFrame(gameLoop);
                document.getElementById('pause-btn').textContent = 'ç»§ç»­æ¸¸æˆ';
            } else {
                gameLoop = requestAnimationFrame(updateGame);
                document.getElementById('pause-btn').textContent = 'æš‚åœæ¸¸æˆ';
            }
        }
        
        // ==================== ç»“æŸæ¸¸æˆ ====================
        function endGame() {
            gameRunning = false;
            cancelAnimationFrame(gameLoop);
            const gameOverScreen = document.getElementById('game-over');
            document.getElementById('final-score').textContent = `å¾—åˆ†: ${score}`;
            document.getElementById('final-level').textContent = `ç­‰çº§: ${playerLevel}`;
            document.getElementById('final-combo').textContent = `æœ€é«˜è¿å‡»: ${maxCombo}`;
            gameOverScreen.style.display = 'flex';
            document.getElementById('start-btn').textContent = 'å¼€å§‹æ¸¸æˆ';
        }
        
        // ==================== æ›´æ–°UI ====================
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('health').textContent = Math.round(health);
            document.getElementById('level').textContent = playerLevel;
            document.getElementById('combo').textContent = combo;
            let averageDamage = player.damage * (1 + criticalChance * (criticalMultiplier - 1));
            document.getElementById('damage-value').textContent = Math.floor(averageDamage * (1 + combo/100));
            updateAbilityCooldowns();
            updateAutoToggleDisplay();
        }
        
        // æŠ€èƒ½å†·å´æ˜¾ç¤º
        function updateAbilityCooldowns() {
            const now = Date.now();
            for (let i = 1; i <= 5; i++) {
                const abilityKey = Object.keys(abilities)[i-1];
                const ability = abilities[abilityKey];
                const cooldownElement = document.getElementById(`cooldown${i}`);
                if (!ability) continue;
                const timeSinceLastUse = now - ability.lastUsed;
                const cooldownPercent = Math.min(100, (timeSinceLastUse / ability.cooldown) * 100);
                cooldownElement.style.height = `${100 - cooldownPercent}%`;
                if (timeSinceLastUse < ability.cooldown) {
                    cooldownElement.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
                } else {
                    cooldownElement.style.backgroundColor = ability.auto ? 'rgba(0, 255, 0, 0.5)' : 'transparent';
                }
            }
        }
        
        // è‡ªåŠ¨é‡Šæ”¾æ˜¾ç¤º
        function updateAutoToggleDisplay() {
            for (let i = 1; i <= 5; i++) {
                const abilityKey = Object.keys(abilities)[i-1];
                const ability = abilities[abilityKey];
                const toggleElement = document.getElementById(`auto-toggle-${i}`);
                if (!ability) continue;
                if (ability.auto) {
                    toggleElement.classList.add('active');
                } else {
                    toggleElement.classList.remove('active');
                }
            }
        }
        
        // ==================== ç”Ÿæˆæ•Œäºº ====================
        function spawnWave() {
            enemiesRemaining = Math.min(4 + wave * 2, 25);
            for (let i = 0; i < enemiesRemaining; i++) {
                let enemyType;
                const rand = Math.random();
                if (wave < 3) {
                    if (rand < 0.7) enemyType = 'normal';
                    else if (rand < 0.9) enemyType = 'fast';
                    else enemyType = 'gqh';
                } else if (wave < 5) {
                    if (rand < 0.5) enemyType = 'normal';
                    else if (rand < 0.7) enemyType = 'fast';
                    else if (rand < 0.8) enemyType = 'tank';
                    else if (rand < 0.9) enemyType = 'gqh';
                    else enemyType = 'shooter';
                } else if (wave < 8) {
                    if (rand < 0.3) enemyType = 'normal';
                    else if (rand < 0.45) enemyType = 'fast';
                    else if (rand < 0.55) enemyType = 'tank';
                    else if (rand < 0.65) enemyType = 'shooter';
                    else if (rand < 0.7) enemyType = 'gqh';
                    else if (rand < 0.8) enemyType = 'splitter';
                    else if (rand < 0.95) enemyType = 'gay0';
                    else enemyType = 'summoner';
                } else if (wave < 12) {
                    if (rand < 0.25) enemyType = 'normal';
                    else if (rand < 0.35) enemyType = 'fast';
                    else if (rand < 0.45) enemyType = 'tank';
                    else if (rand < 0.55) enemyType = 'shooter';
                    else if (rand < 0.6) enemyType = 'splitter';
                    else if (rand < 0.65) enemyType = 'gqh';
                    else if (rand < 0.75) enemyType = 'gay0';
                    else if (rand < 0.9) enemyType = 'sigma';
                    else enemyType = 'summoner';
               } else {
    if (rand < 0.15) enemyType = 'normal';
    else if (rand < 0.25) enemyType = 'fast';
    else if (rand < 0.35) enemyType = 'tank';
    else if (rand < 0.45) enemyType = 'shooter';
    else if (rand < 0.5) enemyType = 'splitter';
    else if (rand < 0.55) enemyType = 'gqh';
    else if (rand < 0.65) enemyType = 'gay0';
    else if (rand < 0.75) enemyType = 'sigma';
    else if (rand < 0.85) enemyType = 'summoner';
    else if (rand < 0.9) enemyType = 'hyt';      // æ–°å¢ hytï¼Œ5%æ¦‚ç‡
    else enemyType = 'gqh';
}
                spawnEnemy(enemyType);
            }
            if (wave % 3 === 0) {
                spawnBoss();
            }
        }
        
        function spawnEnemy(type) {
            const enemy = {
                x: Math.random() < 0.5 ? -60 : canvas.width + 60,
                y: Math.random() * canvas.height,
                width: 40,
                height: 40,
                health: 0,
                maxHealth: 0,
                speed: 0,
                color: '#ff5555',
                type: type,
                lastShot: 0,
                shotDelay: 1500,
                bullets: [],
                trail: []
            };
            switch(type) {
                case 'normal':
                    enemy.width = 40; enemy.height = 40;
                    enemy.health = 500 + wave * 30; enemy.maxHealth = enemy.health;
                    enemy.speed = Math.min(2.5 + wave * 0.25,9); enemy.color = '#ff5555'; break;
                case 'fast':
                    enemy.width = 30; enemy.height = 30;
                    enemy.health = 300 + wave * 20; enemy.maxHealth = enemy.health;
                    enemy.speed =Math.min( 6 + wave * 0.4,11); enemy.color = '#ffaa00'; break;
                case 'tank':
                    enemy.width = 70; enemy.height = 70;
                    enemy.health = 1500 + wave * 80; enemy.maxHealth = enemy.health;
                    enemy.speed = Math.min(1.5 + wave * 0.15,7); enemy.color = '#5555ff';
                    enemy.damageReduction = 0.5; break;
                case 'shooter':
                    enemy.width = 45; enemy.height = 45;
                    enemy.health = 400 + wave * 35; enemy.maxHealth = enemy.health;
                    enemy.speed = Math.min(2.5 + wave * 0.2,8); enemy.color = '#aa55ff';
                    enemy.shotDelay = 1200; enemy.range = 600; break;
                case 'splitter':
                    enemy.width = 50; enemy.height = 50;
                    enemy.health = 600 + wave * 50; enemy.maxHealth = enemy.health;
                    enemy.speed = Math.min(2 + wave * 0.2,8); enemy.color = '#55ff55'; break;
                case 'summoner':
                    enemy.width = 60; enemy.height = 60;
                    enemy.health = 800 + wave * 80; enemy.maxHealth = enemy.health;
                    enemy.speed =Math. min(1.5 + wave * 0.15,7); enemy.color = '#ff55ff';
                    enemy.lastSummon = 0; enemy.summonDelay = 5000; break;
                case 'gay0':
                    enemy.width = 45; enemy.height = 45;
                    enemy.health = 600 + wave * 40; enemy.maxHealth = enemy.health;
                    enemy.speed =Math. min(4.5 + wave * 0.3,9); enemy.color = 'rainbow';
                    enemy.shotDelay = 2000; enemy.range = 500; enemy.homingBullets = true; break;
                case 'sigma':
                    enemy.width = 50; enemy.height = 50;
                    enemy.health = 800 + wave * 60; enemy.maxHealth = enemy.health;
                    enemy.speed =Math. min(4 + wave * 0.25,9); enemy.color = '#000000';
                    enemy.secondaryColor = '#ffffff'; enemy.shotDelay = 2500; enemy.range = 450;
                    enemy.laserAttack = true; enemy.splitBullets = true; break;
                case 'gqh':
                    enemy.width = 65; enemy.height = 65;
                    enemy.health = 2000 + wave * 180; enemy.maxHealth = enemy.health;
                    enemy.speed = Math.min(2.5 + wave * 0.2,6.5); enemy.color = '#ff69b4';
                    enemy.shotDelay = 1800; enemy.range = 400; enemy.damageReduction = 0.3; break;
case 'hyt':
    enemy.width = 60; enemy.height = 60;
    enemy.health = 1200 + wave * 300; enemy.maxHealth = enemy.health;
    enemy.speed = Math.min(1.5 + wave * 0.1, 4);
    enemy.color = '#aa0000';
    enemy.damageReduction = 0.3;
    enemy.auraRadius = 180;
    enemy.buffDamageMultiplier = 1.5;
    enemy.buffSpeedMultiplier = 1.3;
    // ===== æ–°å¢ï¼šå›è¡€èƒ½åŠ› =====
    enemy.regenAmount = 300 + wave * 30;      // æ¯æ¬¡å›å¤ç”Ÿå‘½å€¼ï¼Œéšæ³¢æ¬¡å¢åŠ 
    enemy.regenInterval = 800;              // å›å¤é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    enemy.lastRegenTime = Date.now();       // ä¸Šæ¬¡å›å¤æ—¶é—´
    break;
            }
            enemies.push(enemy);
        }
        
        // ==================== ç”ŸæˆBossï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼šç¬¬5ä¸ªBossä¸ºWild flowerğŸŒ¸ï¼‰====================
       // ==================== ç”ŸæˆBossï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼šç¬¬5ä¸ªBossä¸ºWild flowerğŸŒ¸ï¼Œå…¶ä½™éšæœºå‡ºç°WTD Bossæˆ–shadowTï¼‰====================
function spawnBoss() {
    bossActive = true;
    bossSpawnCount++;   // æ¯æ¬¡ç”ŸæˆBossè®¡æ•°+1
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºç¬¬5ã€10ã€15...ä¸ªBoss
    let isWildFlower = (bossSpawnCount % 5 === 0);
    
    if (isWildFlower) {
        // ===== Wild flowerğŸŒ¸ è¶…å¼ºBoss =====
        boss = {
            x: canvas.width / 2 - 100,
            y: -150,
            width: 200,
            height: 200,
            health: 60000 + wave * 10000,
            maxHealth: 60000 + wave * 10000,
            speed: 2.0,
            color: '#ff69b4',
            phase: 1,
            lastShot: 0,
            shotDelay: Math.min(1000 + wave * 3, 2000),
            bullets: [],
            lastPhaseChange: 0,
            phaseChangeDelay: 12000,
            moveDirection: 1,
            pattern: 0,
            lastPatternChange: 0,
            patternChangeDelay: 4000,
            type: 'wildflower',
            spikeCount: 20,
            spikeDamage: 150 + wave * 10,
            spikeSpeed: 18      // å·²åŠ å¿«
        };
    } else {
        // ===== éšæœºç”Ÿæˆæ™®é€šBossï¼ˆWTDï¼‰æˆ– shadowT =====
        const isShadowT = Math.random() < 0.5; // 50%æ¦‚ç‡
        
        // åŸºç¡€å±æ€§ï¼ˆä¸¤è€…å…±ç”¨ä¸€å¥—åŸºç¡€æ•°å€¼ï¼‰
        const baseBoss = {
            x: canvas.width / 2 - 100,
            y: -150,
            width: 200,
            height: 200,
            health: 3000 + wave * 600 + wave * wave,
            maxHealth: 3000 + wave * 600 + wave * wave,
            speed: 1.5,
            phase: 1,
            lastShot: 0,
            shotDelay: 800,
            bullets: [],
            lastPhaseChange: 0,
            phaseChangeDelay: 15000,
            moveDirection: 1,
            pattern: 0,
            lastPatternChange: 0,
            patternChangeDelay: 3000,
        };

        if (isShadowT) {
            boss = {
                ...baseBoss,
                color: '#222222',      // æ·±ç°è‰²ï¼Œä»£è¡¨é˜´å½±
                type: 'shadowT',
                // å¯å¾®è°ƒå±æ€§ï¼Œä¾‹å¦‚é€Ÿåº¦ç¨å¿«
                speed: 1.8,
                shotDelay: 700,
            };
        } else {
            boss = {
                ...baseBoss,
                color: '#ff00ff',      // åŸæ™®é€šBossé¢œè‰²
                type: 'normal',
            };
        }
    }
    
    document.getElementById('boss-health').style.display = 'block';
    updateBossHealthBar();
}
        // æ›´æ–°Bossè¡€æ¡ï¼ˆæ ¹æ®ç±»å‹æ˜¾ç¤ºä¸åŒåç§°ï¼‰
        function updateBossHealthBar() {
            if (!boss) return;
            const healthPercent = (boss.health / boss.maxHealth) * 100;
            document.getElementById('boss-health-bar').style.width = `${healthPercent}%`;
            let bossName;
if (boss.type === 'wildflower') {
    bossName = 'ğŸŒ¸ Wild flower ğŸŒ¸';
} else if (boss.type === 'shadowT') {
    bossName = 'ğŸ‘¤ shadowT';
} else {
    bossName = 'WTD BOSS';
}
            document.getElementById('boss-health-text').textContent = `${bossName}: ${Math.round(healthPercent)}%`;
        }
        
        // ==================== ç»˜åˆ¶ç©å®¶ ====================
        function drawPlayer() {
            ctx.save();
            ctx.fillStyle = player.color;
            ctx.shadowColor = player.color;
            ctx.shadowBlur = 20;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            if (abilities.shield.active) {
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 5;
                ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 30;
                ctx.beginPath(); ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2 + 15, 0, Math.PI * 2); ctx.stroke();
                const pulse = Math.sin(Date.now() / 150) * 0.3 + 0.7;
                ctx.globalAlpha = pulse * 0.6;
                ctx.fillStyle = '#00ffff';
                ctx.beginPath(); ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2 + 10, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(player.x + 8, player.y + 8, 15, 15);
            ctx.fillRect(player.x + player.width - 23, player.y + 8, 15, 15);
            if (frenzyMode) {
                ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 4;
                ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 40;
                ctx.beginPath(); ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2 + 25, 0, Math.PI * 2); ctx.stroke();
                for (let i = 0; i < 8; i++) {
                    const angle = (Date.now() / 200 + i * Math.PI / 4) % (Math.PI * 2);
                    const pulseSize = Math.sin(Date.now() / 100 + i) * 10 + 20;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath(); ctx.arc(player.x + player.width/2 + Math.cos(angle) * 40, player.y + player.height/2 + Math.sin(angle) * 40, pulseSize * 0.3, 0, Math.PI * 2); ctx.fill();
                }
            }
            ctx.restore();
        }
        
        // ==================== ç»˜åˆ¶æ•Œäººï¼ˆå®Œæ•´ä¿ç•™åŸæœ‰æ‰€æœ‰æ•Œäººç»˜åˆ¶ï¼‰====================
        function drawEnemies() {
            enemies.forEach(enemy => {
                if (enemy.type === 'fast' && enemy.trail.length > 0) {
                    enemy.trail.forEach((pos, index) => {
                        const alpha = (index + 1) / enemy.trail.length * 0.3;
                        ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = enemy.color; ctx.fillRect(pos.x, pos.y, enemy.width, enemy.height); ctx.restore();
                    });
                }
                if (enemy.type === 'gay0') {
                    ctx.save();
                    const gradient = ctx.createLinearGradient(enemy.x, enemy.y, enemy.x + enemy.width, enemy.y + enemy.height);
                    gradient.addColorStop(0, '#ff0000'); gradient.addColorStop(0.2, '#ff8800'); gradient.addColorStop(0.4, '#ffff00');
                    gradient.addColorStop(0.6, '#00ff00'); gradient.addColorStop(0.8, '#0088ff'); gradient.addColorStop(1, '#8800ff');
                    ctx.fillStyle = gradient; ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 15; ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    ctx.fillStyle = 'white'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 3; ctx.fillText('Gay0', enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    ctx.restore();
                } else if (enemy.type === 'sigma') {
                    ctx.save();
                    ctx.fillStyle = enemy.color; ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 15; ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    ctx.fillStyle = enemy.secondaryColor;
                    ctx.fillRect(enemy.x + 5, enemy.y, 5, enemy.height); ctx.fillRect(enemy.x + enemy.width - 10, enemy.y, 5, enemy.height);
                    ctx.fillRect(enemy.x, enemy.y + 5, enemy.width, 5); ctx.fillRect(enemy.x, enemy.y + enemy.height - 10, enemy.width, 5);
                    ctx.fillStyle = 'white'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 3; ctx.fillText('Sigma', enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    ctx.restore();
                } else if (enemy.type === 'gqh') {
                    ctx.save();
                    ctx.fillStyle = enemy.color; ctx.shadowColor = enemy.color; ctx.shadowBlur = 20; ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3; ctx.strokeRect(enemy.x + 3, enemy.y + 3, enemy.width - 6, enemy.height - 6);
                    ctx.fillStyle = 'white'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 3; ctx.fillText('gqhå­¦å§', enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    ctx.fillStyle = '#ff1493';
                    ctx.beginPath(); ctx.moveTo(enemy.x + 15, enemy.y + 15);
                    ctx.bezierCurveTo(enemy.x + 15, enemy.y + 10, enemy.x + 20, enemy.y + 10, enemy.x + 20, enemy.y + 15);
                    ctx.bezierCurveTo(enemy.x + 20, enemy.y + 20, enemy.x + 15, enemy.y + 25, enemy.x + 15, enemy.y + 25);
                    ctx.bezierCurveTo(enemy.x + 15, enemy.y + 25, enemy.x + 10, enemy.y + 20, enemy.x + 10, enemy.y + 15);
                    ctx.bezierCurveTo(enemy.x + 10, enemy.y + 10, enemy.x + 15, enemy.y + 10, enemy.x + 15, enemy.y + 15);
                    ctx.fill();
                    ctx.restore();
                }else if (enemy.type === 'hyt') {
    ctx.save();
    // ç»˜åˆ¶çº¢è‰²é¢†åŸŸå…‰ç¯
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = '#ff0000';
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.auraRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 0.4;
    ctx.strokeStyle = '#ff3333';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // ç»˜åˆ¶æ€ªç‰©æœ¬ä½“
    ctx.globalAlpha = 1;
    ctx.fillStyle = enemy.color;
    ctx.shadowColor = enemy.color;
    ctx.shadowBlur = 15;
    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
    
    ctx.fillStyle = 'white';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'black';
    ctx.shadowBlur = 3;
    ctx.fillText('HYK', enemy.x + enemy.width/2, enemy.y + enemy.height/2);
    ctx.restore();
}
else {
                    ctx.fillStyle = enemy.color; ctx.shadowColor = enemy.color; ctx.shadowBlur = 15; ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    ctx.fillStyle = 'white'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowBlur = 0;
                    let enemyText = 'WTD';
                    if (enemy.type === 'fast') enemyText = 'ğŸ˜ˆ';
                    if (enemy.type === 'tank') enemyText = 'å¥¶é¾™';
                    if (enemy.type === 'shooter') enemyText = 'ğŸ˜¡';
                    if (enemy.type === 'splitter') enemyText = 'yyy';
                    if (enemy.type === 'summoner') enemyText = 'Null';
                    ctx.fillText(enemyText, enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                }
                if (enemy.health < enemy.maxHealth) {
                    const healthPercent = enemy.health / enemy.maxHealth;
                    const barWidth = Math.min(enemy.width, 50);
                    const barHeight = 6;
                    const barX = enemy.x + (enemy.width - barWidth) / 2;
                    const barY = enemy.y - 10;
                    ctx.fillStyle = '#ff0000'; ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = enemy.type === 'tank' ? '#00aa00' : enemy.type === 'sigma' ? '#00ffff' : enemy.type === 'gqh' ? '#ff69b4' : '#00ff00';
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    ctx.strokeStyle = '#000000'; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
if (enemy.healedEffect && Date.now() < enemy.healedEffectEndTime) {
                    ctx.save();
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 20;
                    ctx.strokeRect(enemy.x - 2, enemy.y - 2, enemy.width + 4, enemy.height + 4);
                    ctx.restore();
                }
            });
            if (boss) drawBoss();
        }
        
        // ==================== ç»˜åˆ¶Bossï¼ˆæ–°å¢Wild floweråˆ†æ”¯ï¼‰====================
        // ==================== ç»˜åˆ¶Bossï¼ˆæ–°å¢Wild floweråˆ†æ”¯ï¼Œå¹¶æ”¯æŒWTD Bossä¸shadowTå›¾ç‰‡ï¼‰====================
function drawBoss() {
    ctx.save();
    if (boss.type === 'wildflower') {
        // Wild flowerğŸŒ¸ ç‹¬ç‰¹å¤–è§‚ï¼ˆä¿æŒä¸å˜ï¼‰
        ctx.fillStyle = 'rgba(255, 105, 180, 0.9)';
        ctx.shadowColor = '#ff69b4';
        ctx.shadowBlur = 40;
        ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
        ctx.fillStyle = '#ffb6c1';
        ctx.shadowBlur = 30;
        ctx.beginPath(); ctx.arc(boss.x - 20, boss.y + boss.height/2, 30, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(boss.x + boss.width + 20, boss.y + boss.height/2, 30, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(boss.x + boss.width/2, boss.y - 20, 30, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(boss.x + boss.width/2, boss.y + boss.height + 20, 30, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ff1493';
        ctx.shadowBlur = 30;
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('ğŸŒ¸', boss.x + boss.width/2, boss.y + boss.height/2);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 28px Arial';
        ctx.shadowBlur = 10;
        ctx.fillText('Wild flower', boss.x + boss.width/2, boss.y - 40);
    } else {
        // æ™®é€š Boss æˆ– shadowTï¼šä½¿ç”¨å¯¹åº”å¤´åƒå›¾ç‰‡
        let img = null;
        if (boss.type === 'shadowT') {
            img = shadowTImage;
        } else {
            img = bossImage; // æ™®é€š WTD Boss å›¾ç‰‡
        }

        if (img && img.complete) {
            // å›¾ç‰‡åŠ è½½å®Œæˆï¼Œç»˜åˆ¶å›¾ç‰‡
            ctx.drawImage(img, boss.x, boss.y, boss.width, boss.height);
        } else {
            // å›¾ç‰‡æœªåŠ è½½ï¼Œæ˜¾ç¤ºå¤‡ç”¨å›¾å½¢ï¼ˆé¢œè‰²æ–¹å— + æ–‡å­—ï¼‰
            ctx.fillStyle = boss.color || '#ff00ff';
            ctx.shadowColor = boss.color || '#ff00ff';
            ctx.shadowBlur = 30;
            ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
            ctx.fillStyle = '#ff5555';
            ctx.beginPath(); ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, 50, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.shadowColor = 'black'; ctx.shadowBlur = 10;
            ctx.fillText(boss.type === 'shadowT' ? 'shadowT' : 'WTD BOSS', boss.x + boss.width/2, boss.y + boss.height/2);
        }

        // åŸæœ‰ç›¸ä½ç‰¹æ•ˆä¿ç•™ï¼ˆä¸å½±å“å›¾ç‰‡ï¼‰
        if (boss.phase === 2) {
            const pulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
            ctx.strokeStyle = `rgba(255, 0, 0, ${pulse})`; ctx.lineWidth = 8;
            ctx.shadowColor = 'red'; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, boss.width/2 + 30, 0, Math.PI * 2); ctx.stroke();
        } else if (boss.phase === 3) {
            ctx.save();
            ctx.translate(boss.x + boss.width/2, boss.y + boss.height/2);
            ctx.rotate(Date.now() / 500);
            ctx.fillStyle = '#ffff00'; ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 20;
            for (let i = 0; i < 6; i++) {
                ctx.save(); ctx.rotate(i * Math.PI / 3); ctx.fillRect(-20, -20, 40, 40); ctx.restore();
            }
            ctx.restore();
        }
    }
    ctx.restore();
}
        
        // ==================== ç»˜åˆ¶å­å¼¹ï¼ˆæ–°å¢ä¸‰è§’å½¢å°–åˆºï¼‰====================
        function drawBullets() {
            // ç©å®¶å­å¼¹
            player.bullets.forEach(bullet => {
                ctx.save();
                if (frenzyMode) { ctx.fillStyle = '#ffff00'; ctx.shadowColor = '#ffff00'; }
                else if (bullet.explosive) { ctx.fillStyle = '#ffaa00'; ctx.shadowColor = '#ffaa00'; }
                else { ctx.fillStyle = '#00ffaa'; ctx.shadowColor = '#00ffaa'; }
                ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2); ctx.fill();
                if (player.tripleShot) {
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath(); ctx.arc(bullet.x, bullet.y, bullet.radius * 1.5, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                }
                ctx.restore();
            });
            
            // æ•Œäººå­å¼¹ï¼ˆåŒ…æ‹¬æ–°å¢ä¸‰è§’å½¢å°–åˆºï¼‰
            enemyBullets.forEach(bullet => {
                ctx.save();
                if (bullet.laser) {
                    ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = bullet.radius;
                    ctx.shadowColor = '#ff00ff'; ctx.shadowBlur = 20;
                    ctx.beginPath(); ctx.moveTo(bullet.startX, bullet.startY); ctx.lineTo(bullet.x, bullet.y); ctx.stroke();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath(); ctx.arc(bullet.x, bullet.y, bullet.radius * 1.5, 0, Math.PI * 2); ctx.fill();
                }
                else if (bullet.rainbow) {
                    const gradient = ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bullet.radius);
                    gradient.addColorStop(0, '#ff0000'); gradient.addColorStop(0.25, '#ffff00'); gradient.addColorStop(0.5, '#00ff00');
                    gradient.addColorStop(0.75, '#0088ff'); gradient.addColorStop(1, '#8800ff');
                    ctx.fillStyle = gradient; ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 15;
                    ctx.beginPath(); ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2); ctx.fill();
                }
                else if (bullet.heart) {
                    ctx.fillStyle = '#ff69b4'; ctx.shadowColor = '#ff69b4'; ctx.shadowBlur = 15;
                    ctx.beginPath(); const size = bullet.radius * 1.5;
                    ctx.moveTo(bullet.x, bullet.y - size/2);
                    ctx.bezierCurveTo(bullet.x + size/2, bullet.y - size, bullet.x + size, bullet.y - size/2, bullet.x, bullet.y + size/2);
                    ctx.bezierCurveTo(bullet.x - size, bullet.y - size/2, bullet.x - size/2, bullet.y - size, bullet.x, bullet.y - size/2);
                    ctx.fill();
                }
                // ===== æ–°å¢ï¼šWild flowerçš„ä¸‰è§’å½¢å°–åˆº =====
                else if (bullet.shape === 'spike') {
                    ctx.translate(bullet.x, bullet.y);
                    const angle = Math.atan2(bullet.vy, bullet.vx);
                    ctx.rotate(angle);
                    ctx.fillStyle = '#ff69b4';
                    ctx.shadowColor = '#ff69b4';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.moveTo(bullet.radius * 1.5, 0);
                    ctx.lineTo(-bullet.radius, -bullet.radius);
                    ctx.lineTo(-bullet.radius, bullet.radius);
                    ctx.closePath();
                    ctx.fill();
                }
                else {
                    ctx.fillStyle = bullet.color || '#aa55ff';
                    ctx.shadowColor = bullet.color || '#aa55ff';
                    ctx.shadowBlur = 15;
                    ctx.beginPath(); ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            });
        }
        
        // ==================== ç»˜åˆ¶ç²’å­ ====================
        function drawParticles() {
            particles.forEach((particle, index) => {
                ctx.save();
                ctx.globalAlpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color;
                if (particle.type === 'circle') {
                    ctx.beginPath(); ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2); ctx.fill();
                } else if (particle.type === 'square') {
                    ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                } else if (particle.type === 'star') {
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5;
                        const radius = particle.size;
                        ctx.lineTo(particle.x + Math.cos(angle) * radius, particle.y + Math.sin(angle) * radius);
                    }
                    ctx.closePath(); ctx.fill();
                } else if (particle.type === 'rainbow') {
                    const gradient = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.size);
                    gradient.addColorStop(0, '#ff0000'); gradient.addColorStop(0.25, '#ffff00'); gradient.addColorStop(0.5, '#00ff00');
                    gradient.addColorStop(0.75, '#0088ff'); gradient.addColorStop(1, '#8800ff');
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2); ctx.fill();
                } else if (particle.type === 'electric') {
                    ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(particle.x, particle.y, particle.size * 1.5, 0, Math.PI * 2); ctx.stroke();
                } else if (particle.type === 'heart') {
                    ctx.fillStyle = '#ff69b4';
                    ctx.beginPath(); const size = particle.size;
                    ctx.moveTo(particle.x, particle.y - size/2);
                    ctx.bezierCurveTo(particle.x + size/2, particle.y - size, particle.x + size, particle.y - size/2, particle.x, particle.y + size/2);
                    ctx.bezierCurveTo(particle.x - size, particle.y - size/2, particle.x - size/2, particle.y - size, particle.x, particle.y - size/2);
                    ctx.fill();
                }
                ctx.restore();
                particle.x += particle.vx; particle.y += particle.vy; particle.life--;
                if (particle.life <= 0) particles.splice(index, 1);
            });
        }
        
        // ==================== ç»˜åˆ¶æ— äººæœº ====================
        function drawDrones() {
            if (!abilities.drone.active) return;
            abilities.drone.drones.forEach(drone => {
                ctx.save();
                ctx.fillStyle = '#ffff00'; ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(drone.x, drone.y, 15, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(drone.x, drone.y, 8, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(drone.x, drone.y, 12, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();
            });
        }
        
        // ==================== ç§»åŠ¨ç©å®¶ ====================
        function movePlayer() {
            let moveX = 0, moveY = 0;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveX -= player.speed;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) moveX += player.speed;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) moveY -= player.speed;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) moveY += player.speed;
            if (moveX !== 0 && moveY !== 0) { moveX *= 0.7071; moveY *= 0.7071; }
            player.x += moveX; player.y += moveY;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
            if (player.regenHealth && health < maxHealth) {
                health += player.regenRate; if (health > maxHealth) health = maxHealth; updateUI();
            }
        }
        
        // ==================== ç§»åŠ¨æ•Œäººï¼ˆä¿ç•™åŸé€»è¾‘ï¼Œç•¥ä½œé€‚é…ï¼‰====================
                // ==================== ç§»åŠ¨æ•Œäººï¼ˆæ–°å¢hytå›è¡€ï¼‰====================
        function moveEnemies() {
            const now = Date.now(); // ç”¨äºæ—¶é—´åˆ¤æ–­
            
            // ---- é‡ç½®hytå¢ç›Šæ ‡å¿— ----
            enemies.forEach(e => e.hytBuffed = false);
            
            // ---- hyté¢†åŸŸå¢ç›Šè®¡ç®—ï¼ˆä¼¤å®³åŠ æˆã€é€Ÿåº¦åŠ æˆï¼‰----
            enemies.forEach(hyt => {
                if (hyt.type === 'hyt') {
                    enemies.forEach(e => {
                        const dx = (e.x + e.width/2) - (hyt.x + hyt.width/2);
                        const dy = (e.y + e.height/2) - (hyt.y + hyt.height/2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance <= hyt.auraRadius) {
                            e.hytBuffed = true;
                        }
                    });
                }
            });
            
            // ---- hyté¢†åŸŸå›è¡€ï¼ˆæ¯0.8ç§’ä¸€æ¬¡ï¼‰----
            enemies.forEach(hyt => {
                if (hyt.type === 'hyt' && !timeStopActive) {
                    if (now - (hyt.lastRegenTime || 0) > hyt.regenInterval) {
                        hyt.lastRegenTime = now;
                        enemies.forEach(e => {
                            const dx = (e.x + e.width/2) - (hyt.x + hyt.width/2);
                            const dy = (e.y + e.height/2) - (hyt.y + hyt.height/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance <= hyt.auraRadius) {
                                // å›å¤ç”Ÿå‘½å€¼
                                e.health = Math.min(e.maxHealth, e.health + hyt.regenAmount);
                                // æ·»åŠ è¢«å›è¡€ç‰¹æ•ˆæ ‡è®°ï¼ˆæŒç»­500msï¼‰
                                e.healedEffect = true;
                                e.healedEffectEndTime = now + 500;
                                // ç”Ÿæˆç»¿è‰²ç²’å­æ•ˆæœ
                                createParticles(e.x + e.width/2, e.y + e.height/2, 5, '#00ff00', 'heart');
                            }
                        });
                    }
                }
            });
            
            // ---- åŸæœ‰æ•Œäººç§»åŠ¨ã€æ”»å‡»ã€ç¢°æ’é€»è¾‘ï¼ˆä¿æŒä¸å˜ï¼‰----
            enemies.forEach((enemy, enemyIndex) => {
                if (enemy.type === 'fast') {
                    enemy.trail.push({x: enemy.x, y: enemy.y});
                    if (enemy.trail.length > 5) enemy.trail.shift();
                }
                const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
                const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0 && !timeStopActive) {
                    let moveSpeed = enemy.speed;
                    if (enemy.hytBuffed) moveSpeed *= enemy.buffSpeedMultiplier || 1.3;
                    enemy.x += (dx / distance) * moveSpeed;
                    enemy.y += (dy / distance) * moveSpeed;
                }
                if (enemy.type === 'shooter' || enemy.type === 'gay0' || enemy.type === 'sigma' || enemy.type === 'gqh') {
                    if (now - enemy.lastShot > enemy.shotDelay && distance < enemy.range && !timeStopActive) {
                        if (enemy.type === 'gay0') shootGay0(enemy);
                        else if (enemy.type === 'sigma') shootSigma(enemy);
                        else if (enemy.type === 'gqh') shootGqh(enemy);
                        else shootEnemy(enemy);
                        enemy.lastShot = now;
                    }
                }
                if (enemy.type === 'summoner') {
                    if (now - enemy.lastSummon > enemy.summonDelay && !timeStopActive) {
                        for (let i = 0; i < 2; i++) {
                            enemies.push({
                                x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2,
                                width: 30, height: 30, health: 200, maxHealth: 200, speed: 2.5,
                                color: '#ff8888', type: 'normal'
                            });
                            enemiesRemaining++;
                        }
                        enemy.lastSummon = now;
                    }
                }
                // ç¢°æ’ç©å®¶
                if (!abilities.shield.active && !godMode &&
                    enemy.x < player.x + player.width && enemy.x + enemy.width > player.x &&
                    enemy.y < player.y + player.height && enemy.y + enemy.height > player.y) {
                    if (Math.random() * 100 > player.dodgeChance) {
                        let damage = enemy.type === 'gqh' ? 25 : enemy.type === 'tank' ? 20 : 10;
                        if (enemy.hytBuffed) damage *= 1.5;
                        health -= damage;
                        updateUI();
                        createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 15, '#ff0000');
                        if (health <= 0) { health = 0; endGame(); }
                    }
                    enemies.splice(enemyIndex, 1);
                    enemiesRemaining--;
                    resetCombo();
                }
            });
            
            if (boss && !timeStopActive) moveBoss();
        }
        
        // ==================== ç§»åŠ¨Bossï¼ˆæ–°å¢Wild floweré˜¶æ®µå˜åŒ–ï¼‰====================
        function moveBoss() {
            boss.x += boss.speed * boss.moveDirection;
            if (boss.x <= 0 || boss.x + boss.width >= canvas.width) {
                boss.moveDirection *= -1;
                boss.x = Math.max(0, Math.min(canvas.width - boss.width, boss.x));
            }
            boss.y = 100 + Math.sin(Date.now() / 1800) * 50;
            
            const now = Date.now();
            if (now - boss.lastPhaseChange > boss.phaseChangeDelay) {
                boss.phase++;
                boss.lastPhaseChange = now;
                if (boss.phase > 3) boss.phase = 1;
                
                if (boss.type === 'wildflower') {
                    // Wild floweré˜¶æ®µå¼ºåŒ–
                    if (boss.phase === 2) {
                        boss.shotDelay = 200; boss.spikeCount = 8; boss.spikeDamage = 35; boss.speed = 2.5;
                    } else if (boss.phase === 3) {
                        boss.shotDelay = 120; boss.spikeCount = 10; boss.spikeDamage = 40; boss.speed = 3.0;
                    } else {
                        boss.shotDelay = 300; boss.spikeCount = 6; boss.spikeDamage = 30; boss.speed = 2.0;
                    }
                } else {
                    // æ™®é€šBossé˜¶æ®µ
                    if (boss.phase === 2) { boss.shotDelay = 500; boss.speed = 2.5; }
                    else if (boss.phase === 3) { boss.shotDelay = 300; boss.speed = 3.5; }
                    else { boss.shotDelay = 800; boss.speed = 1.5; }
                }
            }
            
            // æ”»å‡»æ¨¡å¼åˆ‡æ¢ï¼ˆä»…æ™®é€šBossï¼‰
            if (boss.type !== 'wildflower') {
                if (now - boss.lastPatternChange > boss.patternChangeDelay) {
                    boss.pattern = (boss.pattern + 1) % 4;
                    boss.lastPatternChange = now;
                }
            }
            
            if (now - boss.lastShot > boss.shotDelay) {
                shootBoss();
                boss.lastShot = now;
            }
        }
        
        // ==================== æ•Œäººå°„å‡»ï¼ˆåŸæœ‰ï¼‰====================
        function shootEnemy(enemy) {
    const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
    const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance === 0) return;
    let damage = 15;
    if (enemy.hytBuffed) damage *= 1.5;
    enemyBullets.push({
        x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2, radius: 8, speed: 12,
        vx: dx / distance, vy: dy / distance, damage: damage, color: '#aa55ff'
    });
}
        function shootGay0(enemy) {
            for (let i = 0; i < 3; i++) {
                const angleOffset = (i - 1) * 0.2;
                const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
                const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance === 0) return;
                const baseAngle = Math.atan2(dy, dx);
                const angle = baseAngle + angleOffset;
let damage = 12;
if (enemy.hytBuffed) damage *= 1.5;
enemyBullets.push({
    x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2, radius: 7, speed: 10,
    vx: Math.cos(angle), vy: Math.sin(angle), damage: damage, rainbow: true, color: '#ffffff',
    homing: true, homingStrength: 0.05
});
        }}
        function shootSigma(enemy) {
            const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
            const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance === 0) return;
            let damage = 25;
if (enemy.hytBuffed) damage *= 1.5;
enemyBullets.push({
    x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2,
    startX: enemy.x + enemy.width/2, startY: enemy.y + enemy.height/2,
    radius: 10, speed: 16, vx: dx / distance, vy: dy / distance, damage: damage,
    laser: true, color: '#ff00ff', split: true, splitCount: 3
});
        }
        function shootGqh(enemy) {
            for (let i = 0; i < 2; i++) {
                const angleOffset = (i - 0.5) * 0.3;
                const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
                const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance === 0) return;
                const baseAngle = Math.atan2(dy, dx);
                const angle = baseAngle + angleOffset;
              let damage = 18;
if (enemy.hytBuffed) damage *= 1.5;
enemyBullets.push({
    x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2, radius: 6, speed: 9,
    vx: Math.cos(angle), vy: Math.sin(angle), damage: damage, heart: true, color: '#ff69b4'
});
            }
        }
        
        // ==================== Bosså°„å‡»ï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼šWild flowerå‘å°„ä¸‰è§’å½¢å°–åˆºï¼‰====================
        function shootBoss() {
            if (!boss) return;
            
            if (boss.type === 'wildflower') {
                const centerX = boss.x + boss.width/2;
                const centerY = boss.y + boss.height/2;
                // å‘å°„å¤šæ–¹å‘å°–åˆº
                for (let i = 0; i < boss.spikeCount; i++) {
                    const angle = (Math.PI * 2 * i / boss.spikeCount) + (Date.now() / 500);
                    enemyBullets.push({
                        x: centerX, y: centerY,
                        startX: centerX, startY: centerY,
                        radius: 8, speed: boss.spikeSpeed,
                        vx: Math.cos(angle), vy: Math.sin(angle),
                        damage: boss.spikeDamage, shape: 'spike', color: '#ff69b4', homing: false
                    });
                }
                // é˜¶æ®µ2/3éšæœºæ•£å°„
                if (boss.phase >= 2 && Math.random() < 0.5) {
                    for (let i = 0; i < boss.spikeCount * 0.5; i++) {
                        const angle = Math.PI * 2 * Math.random();
                        enemyBullets.push({
                            x: centerX, y: centerY,
                            startX: centerX, startY: centerY,
                            radius: 6, speed: boss.spikeSpeed + 2,
                            vx: Math.cos(angle), vy: Math.sin(angle),
                            damage: boss.spikeDamage * 0.8, shape: 'spike', color: '#ffb6c1'
                        });
                    }
                }
            } else {
                // æ™®é€šBosså°„å‡»æ¨¡å¼ï¼ˆåŸæ ·ä¿ç•™ï¼‰
                const centerX = boss.x + boss.width/2;
                const centerY = boss.y + boss.height/2;
                if (boss.pattern === 0) {
                    const dx = (player.x + player.width/2) - centerX;
                    const dy = (player.y + player.height/2) - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance === 0) return;
                    enemyBullets.push({ x: centerX, y: centerY, radius: 15, speed: 7, vx: dx / distance, vy: dy / distance, damage: 25, color: '#ff00ff' });
                } else if (boss.pattern === 1) {
                    for (let i = -1; i <= 1; i++) {
                        const angle = Math.atan2(player.y + player.height/2 - centerY, player.x + player.width/2 - centerX) + i * 0.3;
                        enemyBullets.push({ x: centerX, y: centerY, radius: 12, speed: 8, vx: Math.cos(angle), vy: Math.sin(angle), damage: 20, color: '#ff55ff' });
                    }
                } else if (boss.pattern === 2) {
                    for (let i = 0; i < 12; i++) {
                        const angle = (Math.PI * 2 * i / 12) + Date.now() / 1000;
                        enemyBullets.push({ x: centerX, y: centerY, radius: 10, speed: 9, vx: Math.cos(angle), vy: Math.sin(angle), damage: 15, color: '#ff88ff' });
                    }
                } else if (boss.pattern === 3) {
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i / 8) + Date.now() / 500;
                        enemyBullets.push({ x: centerX, y: centerY, radius: 8, speed: 10, vx: Math.cos(angle), vy: Math.sin(angle), damage: 12, color: '#ffaaff' });
                    }
                }
            }
        }
        
        // ==================== ç©å®¶å°„å‡» ====================
        function shootPlayer() {
            const now = Date.now();
            if (now - player.lastShot < player.shotDelay) return;
            player.lastShot = now;
            const dx = mouse.x - (player.x + player.width/2);
            const dy = mouse.y - (player.y + player.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance === 0) return;
            const baseVx = dx / distance;
            const baseVy = dy / distance;
            let baseDamage = player.damage * (1 + combo / 100);
            for (let i = 0; i < player.bulletCount; i++) {
                let angleOffset = 0;
                if (player.tripleShot && i < 3) angleOffset = (i - 1) * 0.1;
                let bulletVx, bulletVy;
                if (angleOffset !== 0) {
                    const angle = Math.atan2(baseVy, baseVx) + angleOffset;
                    bulletVx = Math.cos(angle); bulletVy = Math.sin(angle);
                } else { bulletVx = baseVx; bulletVy = baseVy; }
                if (player.homing && frenzyMode) {
                    let nearestEnemy = null, nearestDistance = Infinity;
                    enemies.forEach(enemy => {
                        const edx = (enemy.x + enemy.width/2) - (player.x + player.width/2);
                        const edy = (enemy.y + enemy.height/2) - (player.y + player.height/2);
                        const edistance = Math.sqrt(edx * edx + edy * edy);
                        if (edistance < nearestDistance && edistance < 500) { nearestDistance = edistance; nearestEnemy = enemy; }
                    });
                    if (nearestEnemy) {
                        const targetDx = (nearestEnemy.x + nearestEnemy.width/2) - (player.x + player.width/2);
                        const targetDy = (nearestEnemy.y + nearestEnemy.height/2) - (player.y + player.height/2);
                        const targetDistance = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                        if (targetDistance > 0) {
                            bulletVx = bulletVx * 0.7 + targetDx / targetDistance * 0.3;
                            bulletVy = bulletVy * 0.7 + targetDy / targetDistance * 0.3;
                            const bulletSpeed = Math.sqrt(bulletVx * bulletVx + bulletVy * bulletVy);
                            bulletVx /= bulletSpeed; bulletVy /= bulletSpeed;
                        }
                    }
                }
                const bullet = {
                    x: player.x + player.width/2, y: player.y + player.height/2,
                    radius: 8 * player.attackRange, speed: 24, vx: bulletVx, vy: bulletVy,
                    damage: baseDamage, pierce: player.pierce, piercedEnemies: 0,
                    explosive: player.explosive, homing: player.homing,
                    isCritical: false, criticalMultiplier: criticalMultiplier, vampiricRatio: vampiricRatio
                };
                if (Math.random() * 100 < criticalChance) {
                    bullet.isCritical = true; bullet.damage *= criticalMultiplier;
                }
                player.bullets.push(bullet);
            }
            if (player.shotDelay < 50) {
                setTimeout(() => { if (gameRunning && !gamePaused) shootPlayer(); }, player.shotDelay / 2);
            }
        }
        
        // ==================== ç²’å­æ•ˆæœ ====================
        function createParticles(x, y, count, color, type = 'circle') {
            for (let i = 0; i < count; i++) {
                let particleColor = color, particleType = type;
                if (color === 'rainbow') {
                    const colors = ['#ff0000','#ff8800','#ffff00','#00ff00','#0088ff','#8800ff'];
                    particleColor = colors[Math.floor(Math.random() * colors.length)]; particleType = 'rainbow';
                } else if (color === 'electric') { particleColor = '#00ffff'; particleType = 'electric'; }
                else if (color === 'gqh') { particleColor = '#ff69b4'; particleType = 'heart'; }
                particles.push({
                    x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                    size: Math.random() * 8 + 3, color: particleColor,
                    life: Math.random() * 40 + 30, maxLife: 70, type: particleType
                });
            }
        }
        
        // ==================== è¿å‡»ç³»ç»Ÿ ====================
        function addCombo() {
            combo++; if (combo > maxCombo) maxCombo = combo;
            if (combo % 10 === 0) showPowerupIndicator(`è¿å‡» ${combo}ï¼`);
            if (combo >= 50 && !frenzyMode) {
                frenzyMode = true; showPowerupIndicator("ç‹‚çƒ­æ¨¡å¼ï¼");
                player.attackRange = 1.5; player.homing = true;
                setTimeout(() => { if (combo < 50) { frenzyMode = false; player.attackRange = 1.0; player.homing = false; } }, 10000);
            }
            clearTimeout(comboTimeout);
            comboTimeout = setTimeout(() => {
                if (combo > 0) { combo = 0; frenzyMode = false; player.attackRange = 1.0; player.homing = false; updateUI(); }
            }, 3000);
            updateUI();
        }
        function resetCombo() {
            if (combo > 0) { combo = 0; frenzyMode = false; player.attackRange = 1.0; player.homing = false; updateUI(); }
        }
        function showPowerupIndicator(text) {
            const indicator = document.getElementById('powerup-indicator');
            indicator.textContent = text; indicator.style.display = 'block';
            setTimeout(() => { indicator.style.display = 'none'; }, 2000);
        }
        // æ˜¾ç¤ºå¤©èµ‹å‡çº§æç¤ºï¼ˆä¿®æ”¹åï¼Œæ— ç¡®è®¤æŒ‰é’®ï¼Œ2ç§’è‡ªåŠ¨æ¶ˆå¤±ï¼‰
function showUpgradeNotification(upgradeName, upgradeEffect) {
    const notification = document.getElementById('upgrade-notification');
    document.getElementById('upgrade-title').textContent = upgradeName;
    document.getElementById('upgrade-effect').textContent = upgradeEffect;
    notification.style.display = 'block';
    
    // æš‚åœæ¸¸æˆ
    gamePaused = true;
    cancelAnimationFrame(gameLoop);
    
    // 2ç§’åè‡ªåŠ¨å…³é—­å¹¶æ¢å¤æ¸¸æˆ
    setTimeout(() => {
        notification.style.display = 'none';
        gamePaused = false;
        if (gameRunning) {
            gameLoop = requestAnimationFrame(updateGame);
        }
    }, 2000);
}
        
        // ==================== è‡ªåŠ¨é‡Šæ”¾æŠ€èƒ½ ====================
        function autoCastSkills() {
            if (!autoSkills || !gameRunning || gamePaused) return;
            const now = Date.now();
            for (let abilityKey in abilities) {
                const ability = abilities[abilityKey];
                if (ability.auto && now - ability.lastUsed > ability.cooldown) {
                    let shouldCast = false;
                    if (abilityKey === 'chainLightning') shouldCast = enemies.length > 3 || (boss && enemies.length > 0);
                    else if (abilityKey === 'shield') shouldCast = health < maxHealth * 0.5;
                    else if (abilityKey === 'bomb') shouldCast = enemies.length > 5 || (boss && boss.health < boss.maxHealth * 0.3);
                    else if (abilityKey === 'drone') shouldCast = !ability.active || ability.drones.length === 0;
                    else if (abilityKey === 'timeStop') shouldCast = enemyBullets.length > 20;
                    if (shouldCast) {
                        if (abilityKey === 'chainLightning') useChainLightning();
                        else if (abilityKey === 'shield') useShield();
                        else if (abilityKey === 'bomb') useBomb();
                        else if (abilityKey === 'drone') useDrone();
                        else if (abilityKey === 'timeStop') useTimeStop();
                    }
                }
            }
        }
        
        // ==================== æŠ€èƒ½å®ç°ï¼ˆä¿ç•™åŸæ ·ï¼‰====================
        function useChainLightning() { /* å®Œæ•´ä»£ç ï¼Œç¯‡å¹…æ‰€é™ç•¥ï¼ŒåŸæ–‡ä»¶ä¸­å®Œæ•´ä¿ç•™ */ 
            const now = Date.now();
            if (now - abilities.chainLightning.lastUsed < abilities.chainLightning.cooldown) return;
            abilities.chainLightning.lastUsed = now; abilities.chainLightning.active = true;
            const targetEnemies = [...enemies]; if (boss) targetEnemies.push(boss);
            if (targetEnemies.length === 0) return;
            let currentTarget = targetEnemies[0]; let chainCount = 5 + playerLevel * 2;
            for (let i = 0; i < chainCount && currentTarget; i++) {
                const damage = 100 + playerLevel * 20;
                const actualDamage = currentTarget.damageReduction ? damage * (1 - currentTarget.damageReduction) : damage;
                currentTarget.health -= actualDamage;
                createParticles(currentTarget.x + currentTarget.width/2, currentTarget.y + currentTarget.height/2, 25, '#00ffff', 'star');
                if (i > 0) { /* drawLightningè°ƒç”¨ç•¥ */ }
                if (currentTarget.health <= 0) {
                    const isGay0 = currentTarget.type === 'gay0'; const isSigma = currentTarget.type === 'sigma'; const isGqh = currentTarget.type === 'gqh';
                    score += isGay0 ? 200 : isSigma ? 250 : isGqh ? 300 : 100;
                    xp += isGay0 ? 100 : isSigma ? 120 : isGqh ? 150 : 50;
                    enemiesRemaining--;
                    if (isGay0) createParticles(currentTarget.x + currentTarget.width/2, currentTarget.y + currentTarget.height/2, 50, 'rainbow', 'rainbow');
                    else if (isSigma) createParticles(currentTarget.x + currentTarget.width/2, currentTarget.y + currentTarget.height/2, 60, 'electric', 'electric');
                    else if (isGqh) createParticles(currentTarget.x + currentTarget.width/2, currentTarget.y + currentTarget.height/2, 70, 'gqh', 'heart');
                    if (currentTarget !== boss) { const idx = enemies.indexOf(currentTarget); if (idx > -1) enemies.splice(idx, 1); } else defeatBoss();
                }
                let nextTarget = null; let nextDistance = Infinity;
                targetEnemies.forEach(enemy => {
                    if (enemy === currentTarget || enemy.health <= 0) return;
                    const dx = enemy.x - currentTarget.x; const dy = enemy.y - currentTarget.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < nextDistance && distance < 300) { nextDistance = distance; nextTarget = enemy; }
                });
                currentTarget = nextTarget;
            }
            addCombo(); updateUI(); checkLevelUp();
        }
        function useShield() {
            const now = Date.now(); if (now - abilities.shield.lastUsed < abilities.shield.cooldown) return;
            abilities.shield.lastUsed = now; abilities.shield.active = true;
            setTimeout(() => { abilities.shield.active = false; }, abilities.shield.duration);
        }
        function useBomb() { /* å®Œæ•´ä»£ç ç•¥ï¼ŒåŸæ–‡ä»¶ä¸­å®Œæ•´ä¿ç•™ */ 
            const now = Date.now(); if (now - abilities.bomb.lastUsed < abilities.bomb.cooldown) return;
            abilities.bomb.lastUsed = now;
            enemies.forEach(enemy => {
                const dx = canvas.width/2 - (enemy.x + enemy.width/2); const dy = canvas.height/2 - (enemy.y + enemy.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) { enemy.x += dx / distance * 10; enemy.y += dy / distance * 10; }
                const damage = 200 + playerLevel * 50;
                const actualDamage = enemy.damageReduction ? damage * (1 - enemy.damageReduction) : damage;
                enemy.health -= actualDamage;
                createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 30, '#000000', 'circle');
                if (enemy.health <= 0) {
                    const isGay0 = enemy.type === 'gay0'; const isSigma = enemy.type === 'sigma'; const isGqh = enemy.type === 'gqh';
                    score += isGay0 ? 300 : isSigma ? 350 : isGqh ? 400 : 150;
                    xp += isGay0 ? 150 : isSigma ? 180 : isGqh ? 200 : 75;
                    enemiesRemaining--;
                    if (isGay0) createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 80, 'rainbow', 'rainbow');
                    else if (isSigma) createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 90, 'electric', 'electric');
                    else if (isGqh) createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 100, 'gqh', 'heart');
                    const idx = enemies.indexOf(enemy); if (idx > -1) enemies.splice(idx, 1);
                }
            });
            if (boss) {
                const damage = 500 + playerLevel * 100; boss.health -= damage; updateBossHealthBar();
                createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 80, '#000000', 'circle');
                if (boss.health <= 0) defeatBoss();
            }
            addCombo(); updateUI(); checkLevelUp();
        }
        function useDrone() {
            const now = Date.now(); if (now - abilities.drone.lastUsed < abilities.drone.cooldown) return;
            abilities.drone.lastUsed = now; abilities.drone.active = true;
            abilities.drone.drones = [];
            for (let i = 0; i < 4; i++) {
                abilities.drone.drones.push({ x: player.x + (i - 1.5) * 60, y: player.y - 50, angle: 0, lastShot: 0, shotDelay: 400 });
            }
            setTimeout(() => { abilities.drone.active = false; abilities.drone.drones = []; }, 25000);
        }
        function useTimeStop() {
            const now = Date.now(); if (now - abilities.timeStop.lastUsed < abilities.timeStop.cooldown) return;
            abilities.timeStop.lastUsed = now; timeStopActive = true; timeStopEnd = now + abilities.timeStop.duration;
            setTimeout(() => { timeStopActive = false; }, abilities.timeStop.duration);
        }
        
        // ==================== æ›´æ–°æ— äººæœº ====================
        function updateDrones() {
            if (!abilities.drone.active) return;
            const now = Date.now();
            abilities.drone.drones.forEach((drone, index) => {
                drone.angle += 0.03;
                const radius = 100;
                drone.x = player.x + player.width/2 + Math.cos(drone.angle + index * Math.PI * 2/4) * radius;
                drone.y = player.y + player.height/2 + Math.sin(drone.angle + index * Math.PI * 2/4) * radius;
                if (now - drone.lastShot > drone.shotDelay && !timeStopActive) {
                    let nearestEnemy = null, nearestDistance = Infinity;
                    enemies.forEach(enemy => {
                        const dx = enemy.x - drone.x; const dy = enemy.y - drone.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < nearestDistance && distance < 400) { nearestDistance = distance; nearestEnemy = enemy; }
                    });
                    if (nearestEnemy) {
                        const dx = nearestEnemy.x + nearestEnemy.width/2 - drone.x;
                        const dy = nearestEnemy.y + nearestEnemy.height/2 - drone.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > 0) {
                            player.bullets.push({
                                x: drone.x, y: drone.y, radius: 6, speed: 24,
                                vx: dx / distance, vy: dy / distance,
                                damage: player.damage * 0.8, pierce: 1, piercedEnemies: 0, explosive: false
                            });
                            drone.lastShot = now;
                        }
                    }
                }
            });
        }
        
        // ==================== æ›´æ–°å­å¼¹ï¼ˆä¿ç•™åŸé€»è¾‘ï¼‰====================
        function updateBullets() {
            // ç©å®¶å­å¼¹æ›´æ–°ï¼ˆç•¥ï¼Œå®Œæ•´ä¿ç•™åŸä»£ç ï¼‰
            for (let i = player.bullets.length - 1; i >= 0; i--) {
                const bullet = player.bullets[i];
                if (!timeStopActive) { bullet.x += bullet.vx * bullet.speed; bullet.y += bullet.vy * bullet.speed; }
                if (bullet.x < -bullet.radius || bullet.x > canvas.width + bullet.radius || bullet.y < -bullet.radius || bullet.y > canvas.height + bullet.radius) {
                    player.bullets.splice(i, 1); continue;
                }
                let hitEnemy = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (bullet.x > enemy.x && bullet.x < enemy.x + enemy.width && bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {
                        let actualDamage = enemy.damageReduction ? bullet.damage * (1 - enemy.damageReduction) : bullet.damage;
                        if (bullet.isCritical) createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 20, '#ffff00', 'star');
                        enemy.health -= actualDamage;
                        if (bullet.vampiricRatio > 0) {
                            const healAmount = actualDamage * bullet.vampiricRatio;
                            health = Math.min(maxHealth, health + healAmount);
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 5, '#ff0000', 'circle');
                        }
                        if (bullet.explosive) {
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 25, '#ffaa00', 'star');
                            enemies.forEach(otherEnemy => {
                                if (otherEnemy === enemy) return;
                                const dx = otherEnemy.x - enemy.x; const dy = otherEnemy.y - enemy.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < 100) {
                                    const splashDamage = bullet.damage * 0.7;
                                    const actualSplashDamage = otherEnemy.damageReduction ? splashDamage * (1 - otherEnemy.damageReduction) : splashDamage;
                                    otherEnemy.health -= actualSplashDamage;
                                }
                            });
                        } else {
                            if (enemy.type === 'gay0') createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 20, 'rainbow', 'rainbow');
                            else if (enemy.type === 'sigma') createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 20, 'electric', 'electric');
                            else if (enemy.type === 'gqh') createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 25, 'gqh', 'heart');
                            else createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 10, '#00ffaa', 'circle');
                        }
                        addCombo();
                        if (enemy.health <= 0) {
                            const isGay0 = enemy.type === 'gay0'; const isSigma = enemy.type === 'sigma'; const isGqh = enemy.type === 'gqh';
                            score += 20 * (isGqh ? 15 : isSigma ? 10 : isGay0 ? 8 : (enemy.type === 'tank' ? 5 : enemy.type === 'shooter' ? 3 : 1));
                            xp += 10 * (isGqh ? 8 : isSigma ? 6 : isGay0 ? 5 : (enemy.type === 'tank' ? 3 : 1));
                            enemiesRemaining--;
                            if (isGay0) createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 60, 'rainbow', 'rainbow');
                            else if (isSigma) createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 70, 'electric', 'electric');
                            else if (isGqh) createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 80, 'gqh', 'heart');
                            if (enemy.type === 'splitter') {
                                for (let k = 0; k < 3; k++) {
                                    enemies.push({ x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2, width: 25, height: 25, health: 100, maxHealth: 100, speed: 3, color: '#55ff55', type: 'normal' });
                                    enemiesRemaining++;
                                }
                            }
                            enemies.splice(j, 1);
                        }
                        updateUI();
                        bullet.piercedEnemies++;
                        if (bullet.pierce > 0 && bullet.piercedEnemies > bullet.pierce) { player.bullets.splice(i, 1); hitEnemy = true; break; }
                    }
                }
                if (hitEnemy) { checkLevelUp(); continue; }
                if (boss && bullet.x > boss.x && bullet.x < boss.x + boss.width && bullet.y > boss.y && bullet.y < boss.y + boss.height) {
                    let bossDamage = bullet.damage;
                    if (bullet.isCritical) createParticles(bullet.x, bullet.y, 30, '#ffff00', 'star');
                    boss.health -= bossDamage; updateBossHealthBar();
                    createParticles(bullet.x, bullet.y, 15, '#ff00ff', 'circle');
                    if (bullet.explosive) { boss.health -= bossDamage * 0.5; createParticles(bullet.x, bullet.y, 30, '#ffaa00', 'star'); }
                    if (bullet.vampiricRatio > 0) { const healAmount = bossDamage * bullet.vampiricRatio; health = Math.min(maxHealth, health + healAmount); }
                    addCombo();
                    if (boss.health <= 0) defeatBoss();
                    player.bullets.splice(i, 1);
                    checkLevelUp();
                }
            }
            // æ•Œäººå­å¼¹æ›´æ–°ï¼ˆå®Œæ•´ä¿ç•™ï¼‰
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                if (bullet.homing && !timeStopActive) {
                    const dx = (player.x + player.width/2) - bullet.x; const dy = (player.y + player.height/2) - bullet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        bullet.vx = bullet.vx * (1 - bullet.homingStrength) + (dx / distance) * bullet.homingStrength;
                        bullet.vy = bullet.vy * (1 - bullet.homingStrength) + (dy / distance) * bullet.homingStrength;
                        const speed = Math.sqrt(bullet.vx * bullet.vx + bullet.vy * bullet.vy);
                        bullet.vx = (bullet.vx / speed) * (bullet.speed / 10); bullet.vy = (bullet.vy / speed) * (bullet.speed / 10);
                    }
                }
                if (!timeStopActive) { bullet.x += bullet.vx * bullet.speed; bullet.y += bullet.vy * bullet.speed; }
                if (bullet.laser && bullet.split && Math.random() < 0.02 && !timeStopActive) {
                    for (let s = 0; s < bullet.splitCount; s++) {
                        const angle = Math.random() * Math.PI * 2;
                        enemyBullets.push({ x: bullet.x, y: bullet.y, radius: 5, speed: 4, vx: Math.cos(angle), vy: Math.sin(angle), damage: 8, color: '#ff88ff' });
                    }
                    bullet.split = false;
                }
                if (bullet.x < -bullet.radius || bullet.x > canvas.width + bullet.radius || bullet.y < -bullet.radius || bullet.y > canvas.height + bullet.radius) {
                    enemyBullets.splice(i, 1); continue;
                }
                if (!abilities.shield.active && !godMode &&
                    bullet.x > player.x && bullet.x < player.x + player.width &&
                    bullet.y > player.y && bullet.y < player.y + player.height) {
                    if (Math.random() * 100 > player.dodgeChance) {
                        health -= bullet.damage; enemyBullets.splice(i, 1);
                        createParticles(bullet.x, bullet.y, 15, '#ff5555', 'circle');
                        updateUI(); resetCombo();
                        if (health <= 0) { health = 0; endGame(); }
                    }
                }
                if (abilities.shield.active &&
                    bullet.x > player.x - 30 && bullet.x < player.x + player.width + 30 &&
                    bullet.y > player.y - 30 && bullet.y < player.y + player.height + 30) {
                    const dx = bullet.x - (player.x + player.width/2); const dy = bullet.y - (player.y + player.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 60) {
                        bullet.vx = dx / distance; bullet.vy = dy / distance; bullet.color = '#00ffff';
                        createParticles(bullet.x, bullet.y, 8, '#00ffff', 'circle');
                    }
                }
            }
        }
        
        // ==================== å‡»è´¥Boss ====================
        function defeatBoss() {
            score += 1500 + wave * 300; xp += 800 + wave * 150; combo += 50;
            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 150, '#ffff00', 'star');
            document.getElementById('boss-health').style.display = 'none';
            boss = null; bossActive = false;
            updateUI(); checkLevelUp();
        }
        
        // ==================== å‡çº§ç³»ç»Ÿ ====================
        function checkLevelUp() {
            if (xp >= xpToNextLevel) {
                xp -= xpToNextLevel; playerLevel++; xpToNextLevel = Math.floor(xpToNextLevel * 1.3);
                applyRandomUpgrade(); updateUI();
            }
        }
        function applyRandomUpgrade() {
            const availableUpgrades = [];
            for (let upgradeType in upgrades) {
                const upgrade = upgrades[upgradeType];
                const maxLevel = (upgradeType === 'pierce' || upgradeType === 'explosive') ? 1 : 
                                 (upgradeType === 'critical' || upgradeType === 'vampire') ? 10000 : (upgradeType === 'fireRate'?10:10000 );
                if (upgrade.level < maxLevel && score >= upgrade.cost) availableUpgrades.push(upgradeType);
            }
            if (availableUpgrades.length === 0) return;
            const randomIndex = Math.floor(Math.random() * availableUpgrades.length);
            const upgradeType = availableUpgrades[randomIndex];
            const upgrade = upgrades[upgradeType];
            let upgradeEffect = "";
            switch(upgradeType) {
                case 'damage': player.damage *= 1.3; player.attackRange *= 1.1; upgrade.level++; upgrade.cost = Math.floor(upgrade.cost * 1.5); upgradeEffect = `æ”»å‡»åŠ›æå‡30%ï¼Œæ”»å‡»èŒƒå›´æ‰©å¤§10%`; break;
                case 'fireRate': player.shotDelay *= 0.7; if (upgrade.level % 2 === 0) player.bulletCount++; upgrade.level++; upgrade.cost = Math.floor(upgrade.cost * 1.5); upgradeEffect = `å°„é€Ÿæå‡30%${upgrade.level % 2 === 0 ? 'ï¼Œå­å¼¹æ•°é‡+1' : ''}`; break;
                case 'health': maxHealth=Math.floor(maxHealth * 1.2); health = maxHealth; if (upgrade.level >= 2) { player.regenHealth = true; player.regenRate = maxHealth * 0.001; } upgrade.level++; upgrade.cost = Math.floor(upgrade.cost * 1.5); upgradeEffect = `æœ€å¤§ç”Ÿå‘½å€¼æå‡20%${upgrade.level >= 2 ? 'ï¼Œè·å¾—ç”Ÿå‘½æ¢å¤æ•ˆæœ' : ''}`; break;
                case 'speed': player.speed *= 1.3; player.dodgeChance += 5; upgrade.level++; upgrade.cost = Math.floor(upgrade.cost * 1.5); upgradeEffect = `ç§»åŠ¨é€Ÿåº¦æå‡30%ï¼Œé—ªé¿å‡ ç‡+5%`; break;
                case 'pierce': player.pierce = Infinity; upgrade.level++; upgrade.cost = Math.floor(upgrade.cost * 3); upgradeEffect = `å­å¼¹è·å¾—æ— é™ç©¿é€æ•ˆæœ`; break;
                case 'explosive': player.explosive = true; player.damage *= 1.3; upgrade.level++; upgrade.cost = Math.floor(upgrade.cost * 3); upgradeEffect = `å­å¼¹è·å¾—çˆ†ç‚¸æ•ˆæœï¼Œä¼¤å®³æå‡30%`; break;
                case 'critical': criticalChance += 5; if (upgrade.level >= 3) criticalMultiplier = 3.0; upgrade.level++; upgrade.cost = Math.floor(upgrade.cost * 1.8); upgradeEffect = `æš´å‡»ç‡+5%${upgrade.level >= 3 ? 'ï¼Œæš´å‡»ä¼¤å®³æå‡è‡³300%' : ''}`; break;
                case 'vampire': vampiricRatio += 0.002; upgrade.level++; upgrade.cost = Math.floor(upgrade.cost * 1.8); upgradeEffect = `å¸è¡€æ¯”ä¾‹+0.2%ï¼Œå½“å‰å¸è¡€: ${(vampiricRatio * 100).toFixed(1)}%`; break;
            }
            showUpgradeNotification(upgrade.name, upgradeEffect);
        }
        
        // ==================== ç»˜åˆ¶èƒŒæ™¯ ====================
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000000'); gradient.addColorStop(1, '#200050');
            ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            for (let i = 0; i < 80; i++) {
                const x = (i * 29 + Date.now() / 80) % canvas.width;
                const y = (i * 17 + Date.now() / 120) % canvas.height;
                const size = Math.sin(Date.now() / 800 + i) * 2 + 2;
                const alpha = Math.sin(Date.now() / 1000 + i) * 0.5 + 0.5;
                ctx.globalAlpha = alpha; ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(`æ³¢æ¬¡: ${wave}`, canvas.width / 2, 40);
            if (!bossActive) { ctx.font = 'bold 25px Arial'; ctx.fillText(`å‰©ä½™æ•Œäºº: ${enemiesRemaining}`, canvas.width / 2, 80); }
            if (timeStopActive) {
                ctx.fillStyle = 'rgba(0,255,255,0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.font = 'bold 60px Arial'; ctx.fillText('æ—¶é—´åœæ»ï¼', canvas.width / 2, canvas.height / 2);
            }
        }
        
        // ==================== æ¸¸æˆä¸»å¾ªç¯ ====================
        function updateGame() {
            if (!gameRunning || gamePaused) return;
            drawBackground();
            movePlayer(); moveEnemies(); updateBullets(); updateDrones();
            if (autoSkills) autoCastSkills();
            drawEnemies(); drawPlayer(); drawBullets(); drawParticles(); drawDrones();
            if (enemiesRemaining <= 0 && !bossActive) { wave++; spawnWave(); }
            updateAbilityCooldowns();
            gameLoop = requestAnimationFrame(updateGame);
        }
        
        // ==================== äº‹ä»¶ç›‘å¬ ====================
        document.addEventListener('keydown', function(e) {
            keys[e.key] = true;
            if ((e.key === ' ' || e.key === 'x') && gameRunning && !gamePaused) { shootPlayer(); e.preventDefault(); }
            if (e.key === 'q' || e.key === 'Q') useChainLightning();
            if (e.key === 'w' || e.key === 'W') useShield();
            if (e.key === 'e' || e.key === 'E') useBomb();
            if (e.key === 'r' || e.key === 'R') useDrone();
            if (e.key === 't' || e.key === 'T') useTimeStop();
            if (e.key === 'z' || e.key === 'Z') { if (gameRunning && !gamePaused) shootPlayer(); }
        });
        document.addEventListener('keyup', function(e) { keys[e.key] = false; });
        canvas.addEventListener('mousemove', function(e) { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; });
        canvas.addEventListener('mousedown', function(e) { mouse.pressed = true; if (gameRunning && !gamePaused) shootPlayer(); });
        canvas.addEventListener('mouseup', function() { mouse.pressed = false; });
        canvas.addEventListener('click', function(e) { if (gameRunning && !gamePaused) shootPlayer(); });
        setInterval(() => { if (mouse.pressed && gameRunning && !gamePaused) shootPlayer(); }, player.shotDelay);
        
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('pause-btn').addEventListener('click', pauseGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        /*
        document.getElementById('upgrade-close-btn').addEventListener('click', function() {
            document.getElementById('upgrade-notification').style.display = 'none';
            gamePaused = false;
            if (gameRunning) gameLoop = requestAnimationFrame(updateGame);
        });
        */
        for (let i = 1; i <= 5; i++) {
            const toggleElement = document.getElementById(`auto-toggle-${i}`);
            if (toggleElement) {
                toggleElement.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const abilityKey = Object.keys(abilities)[i-1];
                    abilities[abilityKey].auto = !abilities[abilityKey].auto;
                    updateAutoToggleDisplay();
                });
            }
        }
        document.getElementById('instructions-btn').addEventListener('click', function() {
            const panel = document.getElementById('instructions-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });
        document.getElementById('godmode-btn').addEventListener('click', function() {
            godMode = !godMode;
            if (godMode) { this.style.background = 'linear-gradient(to bottom, #ff0000, #cc0000)'; this.textContent = 'ä¸Šå¸æ¨¡å¼(å¼€å¯)'; health = Infinity; }
            else { this.style.background = 'linear-gradient(to bottom, #ff00ff, #aa00ff)'; this.textContent = 'ä¸Šå¸æ¨¡å¼'; health = maxHealth; }
            updateUI();
        });
        
        // ç§»åŠ¨æ§åˆ¶
        document.getElementById('mobile-left').addEventListener('touchstart', function() { keys['ArrowLeft'] = true; });
        document.getElementById('mobile-left').addEventListener('touchend', function() { keys['ArrowLeft'] = false; });
        document.getElementById('mobile-right').addEventListener('touchstart', function() { keys['ArrowRight'] = true; });
        document.getElementById('mobile-right').addEventListener('touchend', function() { keys['ArrowRight'] = false; });
        document.getElementById('mobile-up').addEventListener('touchstart', function() { keys['ArrowUp'] = true; });
        document.getElementById('mobile-up').addEventListener('touchend', function() { keys['ArrowUp'] = false; });
        document.getElementById('mobile-down').addEventListener('touchstart', function() { keys['ArrowDown'] = true; });
        document.getElementById('mobile-down').addEventListener('touchend', function() { keys['ArrowDown'] = false; });
        document.getElementById('mobile-shoot').addEventListener('touchstart', function() { mouse.pressed = true; if (gameRunning && !gamePaused) shootPlayer(); });
        document.getElementById('mobile-shoot').addEventListener('touchend', function() { mouse.pressed = false; });
        document.getElementById('mobile-ability1').addEventListener('touchstart', function() { useChainLightning(); });
        document.getElementById('mobile-ability2').addEventListener('touchstart', function() { useShield(); });
        document.getElementById('mobile-ability3').addEventListener('touchstart', function() { useBomb(); });
        document.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
        
        // åˆå§‹ç»˜åˆ¶
        drawBackground(); drawPlayer(); updateUI();
    </script>
</body>
</html>
