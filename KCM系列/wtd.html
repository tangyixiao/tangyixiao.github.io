<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‡»è´¥WTD - è¶…å¼ºè¿›åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #000000, #200050, #4000a0);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(150, 0, 255, 0.8);
            border: 4px solid #ff00ff;
            max-width: 1100px;
            width: 100%;
            backdrop-filter: blur(10px);
        }
        
        .game-title {
            color: #ff00ff;
            font-size: 4rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 0, 255, 1);
            letter-spacing: 4px;
            background: linear-gradient(to right, #ff00ff, #00ffff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s infinite alternate;
        }
        
        @keyframes titleGlow {
            0% { text-shadow: 0 0 10px rgba(255, 0, 255, 0.8), 0 0 20px rgba(255, 0, 255, 0.6); }
            100% { text-shadow: 0 0 20px rgba(255, 0, 255, 1), 0 0 30px rgba(255, 0, 255, 0.8), 0 0 40px rgba(255, 0, 255, 0.6); }
        }
        
        .subtitle {
            font-size: 1.5rem;
            color: #a0a0ff;
            margin-bottom: 15px;
        }
        
        .game-container {
            position: relative;
            width: 1100px;
            height: 700px;
            background-color: rgba(0, 0, 0, 0.95);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(150, 0, 255, 0.8);
            border: 4px solid #ff00ff;
            margin-bottom: 20px;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
        }
        
        .hud {
            display: grid;
            grid-template-columns: repeat(5, 1fr) 3fr;
            gap: 15px;
            width: 1100px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(150, 0, 255, 0.6);
            border: 3px solid #ff00ff;
        }
        
        .hud-item {
            text-align: center;
            padding: 10px;
            background: rgba(30, 0, 60, 0.9);
            border-radius: 10px;
            border: 2px solid #7a2fff;
        }
        
        .hud-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.9);
            margin-bottom: 5px;
            animation: valuePulse 2s infinite;
        }
        
        @keyframes valuePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .hud-label {
            font-size: 1.1rem;
            color: #a0a0ff;
        }
        
        .ability-bar {
            grid-column: 6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ability {
            width: 70px;
            height: 70px;
            border-radius: 15px;
            background: rgba(50, 20, 80, 0.9);
            border: 3px solid #ff00ff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .ability:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.9);
        }
        
        .ability:active {
            transform: scale(0.95);
        }
        
        .ability-icon {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }
        
        .ability-key {
            font-size: 0.9rem;
            color: #ffff00;
            background: rgba(0, 0, 0, 0.7);
            padding: 3px 6px;
            border-radius: 5px;
        }
        
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 0, 0, 0.8);
            transition: height 0.3s;
        }
        
        .auto-toggle {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #555;
            border: 2px solid #fff;
            cursor: pointer;
        }
        
        .auto-toggle.active {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .controls {
            width: 1100px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 16px 32px;
            font-size: 1.3rem;
            background: linear-gradient(to bottom, #ff00ff, #aa00ff);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.3);
            flex: 1;
            min-width: 160px;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .btn:hover {
            background: linear-gradient(to bottom, #ff33ff, #cc33ff);
            transform: translateY(-4px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        #start-btn {
            background: linear-gradient(to bottom, #00ff88, #00cc66);
        }
        
        #start-btn:hover {
            background: linear-gradient(to bottom, #33ffaa, #33ff88);
        }
        
        #upgrade-btn {
            background: linear-gradient(to bottom, #ffff00, #ffaa00);
        }
        
        #upgrade-btn:hover {
            background: linear-gradient(to bottom, #ffff33, #ffcc33);
        }
        
        .instructions {
            width: 1100px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            padding: 20px;
            margin-top: 10px;
            border: 3px solid #ff00ff;
            box-shadow: 0 0 25px rgba(150, 0, 255, 0.6);
        }
        
        .instructions h2 {
            color: #ff00ff;
            margin-bottom: 15px;
            font-size: 2rem;
            text-shadow: 0 0 15px rgba(255, 0, 255, 0.7);
        }
        
        .instructions-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .instructions-section {
            background: rgba(30, 0, 60, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #7a2fff;
        }
        
        .instructions-section h3 {
            color: #00ffff;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }
        
        .instructions-section ul {
            list-style-type: none;
            padding-left: 10px;
        }
        
        .instructions-section li {
            margin-bottom: 8px;
            color: #a0a0ff;
            padding-left: 20px;
            position: relative;
        }
        
        .instructions-section li:before {
            content: "âš¡";
            color: #ff00ff;
            font-size: 1rem;
            position: absolute;
            left: 0;
            top: 0;
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .game-over h2 {
            font-size: 5rem;
            color: #ff5555;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 85, 85, 1);
            animation: gameOverPulse 1.5s infinite;
        }
        
        @keyframes gameOverPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .game-over p {
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: #00ffaa;
            text-shadow: 0 0 15px rgba(0, 255, 170, 0.9);
        }
        
        .upgrade-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 30, 0.98);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            border-radius: 15px;
            padding: 30px;
        }
        
        .upgrade-screen h2 {
            font-size: 3.5rem;
            color: #ffff00;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.9);
        }
        
        .upgrade-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
            width: 95%;
            max-width: 900px;
        }
        
        .upgrade-option {
            background: rgba(40, 10, 80, 0.95);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            border: 3px solid #ff00ff;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upgrade-option:hover {
            transform: translateY(-15px);
            box-shadow: 0 15px 30px rgba(150, 0, 255, 0.7);
            border-color: #00ffff;
        }
        
        .upgrade-option h3 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }
        
        .upgrade-option p {
            color: #a0a0ff;
            margin-bottom: 15px;
            font-size: 1.1rem;
            min-height: 70px;
        }
        
        .upgrade-cost {
            color: #ffff00;
            font-weight: bold;
            font-size: 1.5rem;
            margin-bottom: 15px;
        }
        
        .upgrade-level {
            color: #00ffaa;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }
        
        .mobile-controls {
            display: none;
            width: 100%;
            margin-top: 20px;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        
        .mobile-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 0, 255, 0.8);
            color: white;
            font-size: 28px;
            border: 4px solid rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            margin: 5px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }
        
        .mobile-shoot {
            background: rgba(0, 255, 255, 0.8);
        }
        
        .mobile-ability {
            background: rgba(255, 255, 0, 0.8);
            font-size: 22px;
        }
        
        .boss-health {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 35px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #ff5555;
            border-radius: 20px;
            overflow: hidden;
            z-index: 10;
            display: none;
        }
        
        .boss-health-bar {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff5555, #ff8888);
            width: 100%;
            transition: width 0.5s;
        }
        
        .boss-health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            font-size: 1.2rem;
        }
        
        .powerup-indicator {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 10px 20px;
            display: none;
            z-index: 10;
            color: #00ffff;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
        }
        
        @media (max-width: 1150px) {
            .game-container, .hud, .controls, .instructions {
                width: 95vw;
            }
            
            .game-container {
                height: 70vh;
            }
            
            .game-title {
                font-size: 3rem;
            }
            
            .ability-bar {
                grid-column: 1 / span 6;
                grid-row: 2;
                margin-top: 10px;
            }
            
            .hud {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .upgrade-options {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .mobile-controls {
                display: flex;
            }
        }
        
        @media (max-width: 750px) {
            .instructions-content {
                grid-template-columns: 1fr;
            }
            
            .upgrade-options {
                grid-template-columns: 1fr;
            }
            
            .hud {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .btn {
                min-width: 140px;
                font-size: 1.1rem;
                padding: 14px 20px;
            }
        }
        
        .auto-toggle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            color: #a0a0ff;
            font-size: 0.9rem;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-left: 10px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: .4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #00ff00;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">å‡»è´¥WTD - è¶…å¼ºè¿›åŒ–</h1>
        <p class="subtitle">æè‡´å¼¹å¹•ä½“éªŒï¼æŠ€èƒ½è‡ªåŠ¨é‡Šæ”¾ï¼Œæ— é™è¿å‡»ï¼</p>
    </div>
    
    <div class="hud">
        <div class="hud-item">
            <div class="hud-label">å¾—åˆ†</div>
            <div id="score" class="hud-value">0</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">ç”Ÿå‘½å€¼</div>
            <div id="health" class="hud-value">200</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">ç­‰çº§</div>
            <div id="level" class="hud-value">1</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">è¿å‡»</div>
            <div id="combo" class="hud-value">0</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">æ”»å‡»åŠ›</div>
            <div id="damage-value" class="hud-value">50</div>
        </div>
        
        <div class="ability-bar">
            <div class="ability" id="ability1" data-key="Q">
                <div class="ability-icon">âš¡</div>
                <div class="ability-key">Q</div>
                <div class="auto-toggle" id="auto-toggle-1"></div>
                <div class="ability-cooldown" id="cooldown1"></div>
            </div>
            <div class="ability" id="ability2" data-key="W">
                <div class="ability-icon">ğŸ›¡ï¸</div>
                <div class="ability-key">W</div>
                <div class="auto-toggle" id="auto-toggle-2"></div>
                <div class="ability-cooldown" id="cooldown2"></div>
            </div>
            <div class="ability" id="ability3" data-key="E">
                <div class="ability-icon">ğŸ’£</div>
                <div class="ability-key">E</div>
                <div class="auto-toggle" id="auto-toggle-3"></div>
                <div class="ability-cooldown" id="cooldown3"></div>
            </div>
            <div class="ability" id="ability4" data-key="R">
                <div class="ability-icon">ğŸŒŸ</div>
                <div class="ability-key">R</div>
                <div class="auto-toggle" id="auto-toggle-4"></div>
                <div class="ability-cooldown" id="cooldown4"></div>
            </div>
            <div class="ability" id="ability5" data-key="T">
                <div class="ability-icon">ğŸŒ€</div>
                <div class="ability-key">T</div>
                <div class="auto-toggle" id="auto-toggle-5"></div>
                <div class="ability-cooldown" id="cooldown5"></div>
            </div>
        </div>
    </div>
    
    <div class="game-container">
        <div class="boss-health" id="boss-health">
            <div class="boss-health-bar" id="boss-health-bar"></div>
            <div class="boss-health-text" id="boss-health-text">WTD BOSS: 100%</div>
        </div>
        
        <div class="powerup-indicator" id="powerup-indicator">
            æ”»å‡»åŠ›æå‡ï¼
        </div>
        
        <canvas id="game-canvas" width="1100" height="700"></canvas>
        
        <div class="game-over" id="game-over">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <p id="final-score">å¾—åˆ†: 0</p>
            <p id="final-level">ç­‰çº§: 1</p>
            <p id="final-combo">æœ€é«˜è¿å‡»: 0</p>
            <button class="btn" id="restart-btn">é‡æ–°å¼€å§‹</button>
        </div>
        
        <div class="upgrade-screen" id="upgrade-screen">
            <h2>é€‰æ‹©å‡çº§</h2>
            <div class="upgrade-options">
                <div class="upgrade-option" id="upgrade-damage">
                    <h3>æ¯ç­æ”»å‡»</h3>
                    <p>å¢åŠ å­å¼¹ä¼¤å®³100%ï¼Œæ”»å‡»èŒƒå›´æ‰©å¤§</p>
                    <div class="upgrade-level">ç­‰çº§: <span id="damage-level">1</span></div>
                    <div class="upgrade-cost">èŠ±è´¹: <span id="damage-cost">100</span> ç§¯åˆ†</div>
                </div>
                <div class="upgrade-option" id="upgrade-fire-rate">
                    <h3>æé™å°„é€Ÿ</h3>
                    <p>å¢åŠ å°„å‡»é€Ÿåº¦150%ï¼Œå¯åŒæ—¶å‘å°„å¤šé¢—å­å¼¹</p>
                    <div class="upgrade-level">ç­‰çº§: <span id="fire-rate-level">1</span></div>
                    <div class="upgrade-cost">èŠ±è´¹: <span id="fire-rate-cost">100</span> ç§¯åˆ†</div>
                </div>
                <div class="upgrade-option" id="upgrade-health">
                    <h3>æ— æ•Œä¹‹èº¯</h3>
                    <p>å¢åŠ æœ€å¤§ç”Ÿå‘½å€¼200%ï¼Œæ¯ç§’æ¢å¤ç”Ÿå‘½å€¼</p>
                    <div class="upgrade-level">ç­‰çº§: <span id="health-level">1</span></div>
                    <div class="upgrade-cost">èŠ±è´¹: <span id="health-cost">100</span> ç§¯åˆ†</div>
                </div>
                <div class="upgrade-option" id="upgrade-speed">
                    <h3>å…‰é€Ÿç§»åŠ¨</h3>
                    <p>å¢åŠ ç§»åŠ¨é€Ÿåº¦100%ï¼Œå¢åŠ é—ªé¿å‡ ç‡</p>
                    <div class="upgrade-level">ç­‰çº§: <span id="speed-level">1</span></div>
                    <div class="upgrade-cost">èŠ±è´¹: <span id="speed-cost">100</span> ç§¯åˆ†</div>
                </div>
                <div class="upgrade-option" id="upgrade-pierce">
                    <h3>æ— é™ç©¿é€</h3>
                    <p>å­å¼¹å¯ä»¥æ— é™ç©¿é€æ•Œäººï¼Œä¼¤å®³ä¸è¡°å‡</p>
                    <div class="upgrade-level">ç­‰çº§: <span id="pierce-level">0</span></div>
                    <div class="upgrade-cost">èŠ±è´¹: <span id="pierce-cost">300</span> ç§¯åˆ†</div>
                </div>
                <div class="upgrade-option" id="upgrade-explosive">
                    <h3>æ ¸çˆ†å­å¼¹</h3>
                    <p>å­å¼¹å‡»ä¸­æ—¶äº§ç”Ÿå¤§èŒƒå›´çˆ†ç‚¸ï¼Œè¿é”ååº”</p>
                    <div class="upgrade-level">ç­‰çº§: <span id="explosive-level">0</span></div>
                    <div class="upgrade-cost">èŠ±è´¹: <span id="explosive-cost">500</span> ç§¯åˆ†</div>
                </div>
            </div>
            <div class="auto-toggle-container">
                è‡ªåŠ¨é‡Šæ”¾æŠ€èƒ½ï¼š
                <label class="toggle-switch">
                    <input type="checkbox" id="auto-skills-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <button class="btn" id="skip-upgrade-btn" style="margin-top: 30px;">è·³è¿‡å‡çº§</button>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn" id="start-btn">å¼€å§‹æ¸¸æˆ</button>
        <button class="btn" id="pause-btn">æš‚åœæ¸¸æˆ</button>
        <button class="btn" id="upgrade-btn">å‡çº§èœå•</button>
        <button class="btn" id="instructions-btn">æ¸¸æˆè¯´æ˜</button>
        <button class="btn" id="godmode-btn">ä¸Šå¸æ¨¡å¼</button>
    </div>
    
    <div class="mobile-controls">
        <div class="mobile-btn" id="mobile-left">â†</div>
        <div class="mobile-btn" id="mobile-up">â†‘</div>
        <div class="mobile-btn" id="mobile-down">â†“</div>
        <div class="mobile-btn" id="mobile-right">â†’</div>
        <div class="mobile-btn mobile-shoot" id="mobile-shoot">âš¡</div>
        <div class="mobile-btn mobile-ability" id="mobile-ability1">Q</div>
        <div class="mobile-btn mobile-ability" id="mobile-ability2">W</div>
        <div class="mobile-btn mobile-ability" id="mobile-ability3">E</div>
    </div>
    
    <div class="instructions" id="instructions-panel" style="display: none;">
        <h2>æ¸¸æˆè¯´æ˜ - è¶…å¼ºè¿›åŒ–ç‰ˆ</h2>
        <div class="instructions-content">
            <div class="instructions-section">
                <h3>è¶…å¼ºåˆå§‹å±æ€§</h3>
                <ul>
                    <li>åˆå§‹ç”Ÿå‘½å€¼ï¼š200ï¼ˆåŸ100ï¼‰</li>
                    <li>åˆå§‹æ”»å‡»åŠ›ï¼š50ï¼ˆåŸ10ï¼‰</li>
                    <li>åˆå§‹å°„é€Ÿï¼šæ¯ç§’10å‘ï¼ˆåŸ5å‘ï¼‰</li>
                    <li>åˆå§‹ç§»åŠ¨é€Ÿåº¦ï¼š8ï¼ˆåŸ5ï¼‰</li>
                    <li>ä¸‰è¿å‘å­å¼¹ï¼Œè‡ªåŠ¨ç„å‡†</li>
                    <li>è¿ç»­å‡»ä¸­æ•Œäººå¢åŠ è¿å‡»ï¼Œæå‡æ”»å‡»åŠ›</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>æŠ€èƒ½ç³»ç»Ÿï¼ˆå¯è‡ªåŠ¨é‡Šæ”¾ï¼‰</h3>
                <ul>
                    <li>Qé”®ï¼šè¶…ç”µç£ç‚® - è¶…å¤§èŒƒå›´è¿é”æ”»å‡»</li>
                    <li>Wé”®ï¼šç»å¯¹é˜²å¾¡ - æ— æ•Œå¹¶åå¼¹æ‰€æœ‰å­å¼¹</li>
                    <li>Eé”®ï¼šé»‘æ´ç‚¸å¼¹ - å¸èšæ•Œäººå¹¶é€ æˆå¤§ä¼¤å®³</li>
                    <li>Ré”®ï¼šæµ®æ¸¸ç‚® - å¬å”¤4ä¸ªè‡ªåŠ¨æ”»å‡»çš„æµ®æ¸¸ç‚®</li>
                    <li>Té”®ï¼šæ—¶é—´åœæ» - å†»ç»“æ‰€æœ‰æ•Œäººå’Œå­å¼¹</li>
                    <li>æŠ€èƒ½å¯ä»¥è®¾ç½®ä¸ºè‡ªåŠ¨é‡Šæ”¾ï¼ˆè§å‡çº§ç•Œé¢ï¼‰</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>å¼ºåŒ–æ•Œäººç³»ç»Ÿ</h3>
                <ul>
                    <li>æ™®é€šWTDï¼šç”Ÿå‘½å€¼200ï¼Œé€Ÿåº¦æ›´å¿«</li>
                    <li>é—ªç”µWTDï¼šè¶…é«˜é€Ÿåº¦ï¼Œæ®‹å½±æ•ˆæœ</li>
                    <li>é‡ç”²WTDï¼šç”Ÿå‘½å€¼1000ï¼Œå‡ä¼¤50%</li>
                    <li>ç‹™å‡»WTDï¼šè¶…è¿œè·ç¦»ç²¾å‡†å°„å‡»</li>
                    <li>å¬å”¤WTDï¼šå¬å”¤æ›´å¤šWTD</li>
                    <li>WTD BOSSï¼šå¤šé‡æ”»å‡»æ¨¡å¼ï¼Œå¤šç§å¼¹å¹•</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>è¿å‡»ç³»ç»Ÿ</h3>
                <ul>
                    <li>è¿ç»­å‡»ä¸­æ•Œäººå¢åŠ è¿å‡»æ•°</li>
                    <li>è¿å‡»æ•°è¶Šé«˜ï¼Œæ”»å‡»åŠ›åŠ æˆè¶Šé«˜</li>
                    <li>è¿å‡»è¶…è¿‡50è¿›å…¥ç‹‚çƒ­çŠ¶æ€</li>
                    <li>ç‹‚çƒ­çŠ¶æ€ï¼šæ”»å‡»èŒƒå›´æ‰©å¤§ï¼Œå­å¼¹è‡ªåŠ¨è¿½è¸ª</li>
                    <li>è¿å‡»ä¸­æ–­å3ç§’å†…é‡æ–°å‡»ä¸­å¯ä¿æŒè¿å‡»</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // è·å–Canvaså’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // æ¸¸æˆçŠ¶æ€
        let gameRunning = false;
        let gamePaused = false;
        let gameLoop;
        let score = 0;
        let health = 200; // å¢å¼ºåˆå§‹ç”Ÿå‘½å€¼
        let maxHealth = 200;
        let playerLevel = 1;
        let xp = 0;
        let xpToNextLevel = 100;
        let wave = 1;
        let enemiesRemaining = 0;
        let bossActive = false;
        let godMode = false;
        let combo = 0;
        let maxCombo = 0;
        let comboTimeout = null;
        let frenzyMode = false; // ç‹‚çƒ­æ¨¡å¼
        let autoSkills = false; // è‡ªåŠ¨é‡Šæ”¾æŠ€èƒ½
        
        // ç©å®¶å±æ€§ï¼ˆå¤§å¹…å¢å¼ºï¼‰
        const player = {
            x: canvas.width / 2 - 25,
            y: canvas.height / 2 - 25,
            width: 50,
            height: 50,
            speed: 8, // å¢å¼ºç§»åŠ¨é€Ÿåº¦
            color: '#00a8ff',
            bullets: [],
            lastShot: 0,
            shotDelay: 100, // å¢å¼ºå°„é€Ÿï¼ˆåŸ200ï¼‰
            damage: 50, // å¢å¼ºæ”»å‡»åŠ›ï¼ˆåŸ10ï¼‰
            pierce: 0,
            explosive: false,
            tripleShot: true, // ä¸‰è¿å‘
            homing: false, // è‡ªåŠ¨è¿½è¸ª
            attackRange: 1.0, // æ”»å‡»èŒƒå›´
            bulletCount: 1, // åŒæ—¶å‘å°„å­å¼¹æ•°
            regenHealth: false, // ç”Ÿå‘½æ¢å¤
            regenRate: 0, // æ¢å¤é€Ÿç‡
            dodgeChance: 0 // é—ªé¿å‡ ç‡
        };
        
        // ç©å®¶å‡çº§çŠ¶æ€
        const upgrades = {
            damage: { level: 1, cost: 100 },
            fireRate: { level: 1, cost: 100 },
            health: { level: 1, cost: 100 },
            speed: { level: 1, cost: 100 },
            pierce: { level: 0, cost: 300 },
            explosive: { level: 0, cost: 500 }
        };
        
        // æŠ€èƒ½ç³»ç»Ÿï¼ˆå¢åŠ æ–°æŠ€èƒ½ï¼‰
        const abilities = {
            chainLightning: {
                name: "è¶…ç”µç£ç‚®",
                key: "Q",
                cooldown: 8000, // 8ç§’
                lastUsed: 0,
                active: false,
                auto: false
            },
            shield: {
                name: "ç»å¯¹é˜²å¾¡",
                key: "W",
                cooldown: 12000, // 12ç§’
                lastUsed: 0,
                active: false,
                duration: 4000, // 4ç§’
                auto: false
            },
            bomb: {
                name: "é»‘æ´ç‚¸å¼¹",
                key: "E",
                cooldown: 15000, // 15ç§’
                lastUsed: 0,
                active: false,
                auto: false
            },
            drone: {
                name: "æµ®æ¸¸ç‚®",
                key: "R",
                cooldown: 20000, // 20ç§’
                lastUsed: 0,
                active: false,
                drones: [],
                auto: false
            },
            timeStop: {
                name: "æ—¶é—´åœæ»",
                key: "T",
                cooldown: 25000, // 25ç§’
                lastUsed: 0,
                active: false,
                duration: 3000, // 3ç§’
                auto: false
            }
        };
        
        // æ—¶é—´åœæ»æ•ˆæœ
        let timeStopActive = false;
        let timeStopEnd = 0;
        
        // æ•Œäººæ•°ç»„
        let enemies = [];
        
        // Bosså¯¹è±¡
        let boss = null;
        
        // ç²’å­æ•ˆæœæ•°ç»„
        let particles = [];
        
        // å­å¼¹æ•°ç»„ï¼ˆç”¨äºè§†è§‰æ•ˆæœï¼‰
        let enemyBullets = [];
        
        // æ§åˆ¶çŠ¶æ€
        const keys = {};
        const mouse = { x: 0, y: 0, pressed: false };
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            score = 0;
            health = maxHealth;
            playerLevel = 1;
            xp = 0;
            xpToNextLevel = 100;
            wave = 1;
            enemiesRemaining = 0;
            bossActive = false;
            combo = 0;
            maxCombo = 0;
            frenzyMode = false;
            timeStopActive = false;
            
            // é‡ç½®ç©å®¶ä½ç½®å’Œå±æ€§
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height / 2 - 25;
            player.bullets = [];
            player.lastShot = 0;
            player.speed = 8;
            player.damage = 50;
            player.pierce = 0;
            player.explosive = false;
            player.tripleShot = true;
            player.homing = false;
            player.attackRange = 1.0;
            player.bulletCount = 1;
            player.regenHealth = false;
            player.regenRate = 0;
            player.dodgeChance = 0;
            
            // é‡ç½®å‡çº§
            upgrades.damage.level = 1;
            upgrades.fireRate.level = 1;
            upgrades.health.level = 1;
            upgrades.speed.level = 1;
            upgrades.pierce.level = 0;
            upgrades.explosive.level = 0;
            
            // é‡ç½®æŠ€èƒ½
            for (let ability in abilities) {
                abilities[ability].lastUsed = 0;
                abilities[ability].active = false;
                abilities[ability].auto = false;
                if (abilities[ability].drones) abilities[ability].drones = [];
            }
            
            // æ¸…ç©ºæ•Œäººå’Œç²’å­
            enemies = [];
            particles = [];
            enemyBullets = [];
            boss = null;
            
            // æ›´æ–°UI
            updateUI();
            
            // éšè—æ¸¸æˆç»“æŸç•Œé¢
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('upgrade-screen').style.display = 'none';
            document.getElementById('boss-health').style.display = 'none';
            document.getElementById('powerup-indicator').style.display = 'none';
            
            // ç”Ÿæˆç¬¬ä¸€æ³¢æ•Œäºº
            spawnWave();
        }
        
        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            if (gameRunning) return;
            
            initGame();
            gameRunning = true;
            gamePaused = false;
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            gameLoop = requestAnimationFrame(updateGame);
            
            // æ›´æ–°æŒ‰é’®æ–‡æœ¬
            document.getElementById('start-btn').textContent = 'æ¸¸æˆä¸­...';
            document.getElementById('pause-btn').textContent = 'æš‚åœæ¸¸æˆ';
        }
        
        // æš‚åœæ¸¸æˆ
        function pauseGame() {
            if (!gameRunning) return;
            
            gamePaused = !gamePaused;
            
            if (gamePaused) {
                cancelAnimationFrame(gameLoop);
                document.getElementById('pause-btn').textContent = 'ç»§ç»­æ¸¸æˆ';
            } else {
                gameLoop = requestAnimationFrame(updateGame);
                document.getElementById('pause-btn').textContent = 'æš‚åœæ¸¸æˆ';
            }
        }
        
        // ç»“æŸæ¸¸æˆ
        function endGame() {
            gameRunning = false;
            cancelAnimationFrame(gameLoop);
            
            // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
            const gameOverScreen = document.getElementById('game-over');
            document.getElementById('final-score').textContent = `å¾—åˆ†: ${score}`;
            document.getElementById('final-level').textContent = `ç­‰çº§: ${playerLevel}`;
            document.getElementById('final-combo').textContent = `æœ€é«˜è¿å‡»: ${maxCombo}`;
            gameOverScreen.style.display = 'flex';
            
            // æ›´æ–°æŒ‰é’®æ–‡æœ¬
            document.getElementById('start-btn').textContent = 'å¼€å§‹æ¸¸æˆ';
        }
        
        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('health').textContent = health;
            document.getElementById('level').textContent = playerLevel;
            document.getElementById('combo').textContent = combo;
            document.getElementById('damage-value').textContent = Math.floor(player.damage * (1 + combo/100));
            
            // æ›´æ–°å‡çº§UI
            document.getElementById('damage-level').textContent = upgrades.damage.level;
            document.getElementById('damage-cost').textContent = upgrades.damage.cost;
            document.getElementById('fire-rate-level').textContent = upgrades.fireRate.level;
            document.getElementById('fire-rate-cost').textContent = upgrades.fireRate.cost;
            document.getElementById('health-level').textContent = upgrades.health.level;
            document.getElementById('health-cost').textContent = upgrades.health.cost;
            document.getElementById('speed-level').textContent = upgrades.speed.level;
            document.getElementById('speed-cost').textContent = upgrades.speed.cost;
            document.getElementById('pierce-level').textContent = upgrades.pierce.level;
            document.getElementById('pierce-cost').textContent = upgrades.pierce.cost;
            document.getElementById('explosive-level').textContent = upgrades.explosive.level;
            document.getElementById('explosive-cost').textContent = upgrades.explosive.cost;
            
            // æ›´æ–°æŠ€èƒ½å†·å´æ˜¾ç¤ºå’Œè‡ªåŠ¨é‡Šæ”¾çŠ¶æ€
            updateAbilityCooldowns();
            updateAutoToggleDisplay();
        }
        
        // æ›´æ–°æŠ€èƒ½å†·å´æ˜¾ç¤º
        function updateAbilityCooldowns() {
            const now = Date.now();
            
            for (let i = 1; i <= 5; i++) {
                const abilityKey = Object.keys(abilities)[i-1];
                const ability = abilities[abilityKey];
                const cooldownElement = document.getElementById(`cooldown${i}`);
                
                if (!ability) continue;
                
                const timeSinceLastUse = now - ability.lastUsed;
                const cooldownPercent = Math.min(100, (timeSinceLastUse / ability.cooldown) * 100);
                
                // è®¾ç½®å†·å´æ¡é«˜åº¦
                cooldownElement.style.height = `${100 - cooldownPercent}%`;
                
                // å¦‚æœæŠ€èƒ½æ­£åœ¨å†·å´ï¼Œæ·»åŠ å†·å´æ ·å¼
                if (timeSinceLastUse < ability.cooldown) {
                    cooldownElement.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
                } else {
                    cooldownElement.style.backgroundColor = ability.auto ? 'rgba(0, 255, 0, 0.5)' : 'transparent';
                }
            }
        }
        
        // æ›´æ–°è‡ªåŠ¨é‡Šæ”¾æ˜¾ç¤º
        function updateAutoToggleDisplay() {
            for (let i = 1; i <= 5; i++) {
                const abilityKey = Object.keys(abilities)[i-1];
                const ability = abilities[abilityKey];
                const toggleElement = document.getElementById(`auto-toggle-${i}`);
                
                if (!ability) continue;
                
                if (ability.auto) {
                    toggleElement.classList.add('active');
                } else {
                    toggleElement.classList.remove('active');
                }
            }
        }
        
        // ç”Ÿæˆæ•Œäººæ³¢æ¬¡
        function spawnWave() {
            enemiesRemaining = 8 + wave * 3; // å¢åŠ æ¯æ³¢æ•Œäººæ•°é‡
            
            for (let i = 0; i < enemiesRemaining; i++) {
                let enemyType;
                const rand = Math.random();
                
                // æ ¹æ®æ³¢æ¬¡å’Œéšæœºæ•°å†³å®šæ•Œäººç±»å‹
                if (wave < 3) {
                    if (rand < 0.8) enemyType = 'normal';
                    else enemyType = 'fast';
                } else if (wave < 6) {
                    if (rand < 0.5) enemyType = 'normal';
                    else if (rand < 0.7) enemyType = 'fast';
                    else if (rand < 0.9) enemyType = 'tank';
                    else enemyType = 'shooter';
                } else if (wave < 10) {
                    if (rand < 0.4) enemyType = 'normal';
                    else if (rand < 0.6) enemyType = 'fast';
                    else if (rand < 0.75) enemyType = 'tank';
                    else if (rand < 0.9) enemyType = 'shooter';
                    else enemyType = 'splitter';
                } else {
                    if (rand < 0.3) enemyType = 'normal';
                    else if (rand < 0.45) enemyType = 'fast';
                    else if (rand < 0.6) enemyType = 'tank';
                    else if (rand < 0.75) enemyType = 'shooter';
                    else if (rand < 0.9) enemyType = 'splitter';
                    else enemyType = 'summoner';
                }
                
                spawnEnemy(enemyType);
            }
            
            // æ¯3æ³¢ç”Ÿæˆä¸€ä¸ªBoss
            if (wave % 3 === 0) {
                spawnBoss();
            }
        }
        
        // ç”Ÿæˆæ•Œäººï¼ˆå¢å¼ºæ•Œäººå±æ€§ï¼‰
        function spawnEnemy(type) {
            const enemy = {
                x: Math.random() < 0.5 ? -60 : canvas.width + 60,
                y: Math.random() * canvas.height,
                width: 40,
                height: 40,
                health: 0,
                maxHealth: 0,
                speed: 0,
                color: '#ff5555',
                type: type,
                lastShot: 0,
                shotDelay: 1500,
                bullets: [],
                trail: [] // æ®‹å½±æ•ˆæœ
            };
            
            // æ ¹æ®ç±»å‹è®¾ç½®å±æ€§ï¼ˆå¤§å¹…å¢å¼ºï¼‰
            switch(type) {
                case 'normal':
                    enemy.width = 40;
                    enemy.height = 40;
                    enemy.health = 200 + wave * 20; // å¢å¼ºç”Ÿå‘½å€¼
                    enemy.maxHealth = enemy.health;
                    enemy.speed = 2 + wave * 0.2; // å¢å¼ºé€Ÿåº¦
                    enemy.color = '#ff5555';
                    break;
                case 'fast':
                    enemy.width = 30;
                    enemy.height = 30;
                    enemy.health = 100 + wave * 15;
                    enemy.maxHealth = enemy.health;
                    enemy.speed = 5 + wave * 0.3; // è¶…é«˜é€Ÿåº¦
                    enemy.color = '#ffaa00';
                    break;
                case 'tank':
                    enemy.width = 70;
                    enemy.height = 70;
                    enemy.health = 1000 + wave * 50; // è¶…é«˜ç”Ÿå‘½å€¼
                    enemy.maxHealth = enemy.health;
                    enemy.speed = 1 + wave * 0.1;
                    enemy.color = '#5555ff';
                    enemy.damageReduction = 0.5; // 50%ä¼¤å®³å‡å…
                    break;
                case 'shooter':
                    enemy.width = 45;
                    enemy.height = 45;
                    enemy.health = 150 + wave * 25;
                    enemy.maxHealth = enemy.health;
                    enemy.speed = 2 + wave * 0.15;
                    enemy.color = '#aa55ff';
                    enemy.shotDelay = 1200;
                    enemy.range = 600; // è¶…è¿œå°„ç¨‹
                    break;
                case 'splitter':
                    enemy.width = 50;
                    enemy.height = 50;
                    enemy.health = 300 + wave * 40;
                    enemy.maxHealth = enemy.health;
                    enemy.speed = 1.5 + wave * 0.15;
                    enemy.color = '#55ff55';
                    break;
                case 'summoner':
                    enemy.width = 60;
                    enemy.height = 60;
                    enemy.health = 400 + wave * 60;
                    enemy.maxHealth = enemy.health;
                    enemy.speed = 1 + wave * 0.1;
                    enemy.color = '#ff55ff';
                    enemy.lastSummon = 0;
                    enemy.summonDelay = 5000; // 5ç§’å¬å”¤ä¸€æ¬¡
                    break;
            }
            
            enemies.push(enemy);
        }
        
        // ç”ŸæˆBossï¼ˆå¤§å¹…å¢å¼ºï¼‰
        function spawnBoss() {
            bossActive = true;
            
            boss = {
                x: canvas.width / 2 - 100,
                y: -150,
                width: 200,
                height: 200,
                health: 2000 + wave * 200, // è¶…é«˜ç”Ÿå‘½å€¼
                maxHealth: 2000 + wave * 200,
                speed: 1.5,
                color: '#ff00ff',
                phase: 1,
                lastShot: 0,
                shotDelay: 800,
                bullets: [],
                lastPhaseChange: 0,
                phaseChangeDelay: 15000, // 15ç§’åˆ‡æ¢ä¸€æ¬¡é˜¶æ®µ
                moveDirection: 1,
                pattern: 0,
                lastPatternChange: 0,
                patternChangeDelay: 3000 // 3ç§’åˆ‡æ¢ä¸€æ¬¡æ”»å‡»æ¨¡å¼
            };
            
            // æ˜¾ç¤ºBossè¡€æ¡
            document.getElementById('boss-health').style.display = 'block';
            updateBossHealthBar();
        }
        
        // æ›´æ–°Bossè¡€æ¡
        function updateBossHealthBar() {
            if (!boss) return;
            
            const healthPercent = (boss.health / boss.maxHealth) * 100;
            document.getElementById('boss-health-bar').style.width = `${healthPercent}%`;
            document.getElementById('boss-health-text').textContent = `WTD BOSS: ${Math.round(healthPercent)}%`;
        }
        
        // ç»˜åˆ¶ç©å®¶
        function drawPlayer() {
            ctx.save();
            
            // ç»˜åˆ¶ç©å®¶ä¸»ä½“
            ctx.fillStyle = player.color;
            ctx.shadowColor = player.color;
            ctx.shadowBlur = 20;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            // å¦‚æœæŠ¤ç›¾æ¿€æ´»ï¼Œç»˜åˆ¶æŠ¤ç›¾æ•ˆæœ
            if (abilities.shield.active) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 5;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2 + 15, 0, Math.PI * 2);
                ctx.stroke();
                
                // æŠ¤ç›¾é—ªçƒæ•ˆæœ
                const pulse = Math.sin(Date.now() / 150) * 0.3 + 0.7;
                ctx.globalAlpha = pulse * 0.6;
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2 + 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // ç»˜åˆ¶ç©å®¶è£…é¥°
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(player.x + 8, player.y + 8, 15, 15);
            ctx.fillRect(player.x + player.width - 23, player.y + 8, 15, 15);
            
            // ç‹‚çƒ­æ¨¡å¼ç‰¹æ•ˆ
            if (frenzyMode) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 40;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2 + 25, 0, Math.PI * 2);
                ctx.stroke();
                
                // ç»˜åˆ¶ç‹‚çƒ­å…‰ç¯
                for (let i = 0; i < 8; i++) {
                    const angle = (Date.now() / 200 + i * Math.PI / 4) % (Math.PI * 2);
                    const pulseSize = Math.sin(Date.now() / 100 + i) * 10 + 20;
                    
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(
                        player.x + player.width/2 + Math.cos(angle) * 40,
                        player.y + player.height/2 + Math.sin(angle) * 40,
                        pulseSize * 0.3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶æ•Œäºº
        function drawEnemies() {
            enemies.forEach(enemy => {
                // ç»˜åˆ¶æ®‹å½±æ•ˆæœï¼ˆä»…å¯¹å¿«é€Ÿæ•Œäººï¼‰
                if (enemy.type === 'fast' && enemy.trail.length > 0) {
                    enemy.trail.forEach((pos, index) => {
                        const alpha = (index + 1) / enemy.trail.length * 0.3;
                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = enemy.color;
                        ctx.fillRect(pos.x, pos.y, enemy.width, enemy.height);
                        ctx.restore();
                    });
                }
                
                // ç»˜åˆ¶æ•Œäººä¸»ä½“
                ctx.fillStyle = enemy.color;
                ctx.shadowColor = enemy.color;
                ctx.shadowBlur = 15;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // ç»˜åˆ¶æ•Œäººæ–‡å­—
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 0;
                
                let enemyText = 'WTD';
                if (enemy.type === 'fast') enemyText = 'é—ªç”µ';
                if (enemy.type === 'tank') enemyText = 'é‡ç”²';
                if (enemy.type === 'shooter') enemyText = 'ç‹™å‡»';
                if (enemy.type === 'splitter') enemyText = 'åˆ†è£‚';
                if (enemy.type === 'summoner') enemyText = 'å¬å”¤';
                
                ctx.fillText(enemyText, enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                
                // ç»˜åˆ¶æ•Œäººè¡€æ¡
                if (enemy.health < enemy.maxHealth) {
                    const healthPercent = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x, enemy.y - 15, enemy.width, 8);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(enemy.x, enemy.y - 15, enemy.width * healthPercent, 8);
                }
            });
            
            // ç»˜åˆ¶Boss
            if (boss) {
                drawBoss();
            }
        }
        
        // ç»˜åˆ¶Boss
        function drawBoss() {
            ctx.save();
            
            // Bossä¸»ä½“
            ctx.fillStyle = boss.color;
            ctx.shadowColor = boss.color;
            ctx.shadowBlur = 30;
            ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
            
            // Bossè£…é¥°
            ctx.fillStyle = '#ff5555';
            ctx.beginPath();
            ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // Bossæ–‡å­—
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            ctx.fillText('WTD BOSS', boss.x + boss.width/2, boss.y + boss.height/2);
            
            // æ ¹æ®é˜¶æ®µæ·»åŠ è§†è§‰æ•ˆæœ
            if (boss.phase === 2) {
                // ç¬¬äºŒé˜¶æ®µ - æ„¤æ€’çŠ¶æ€ï¼Œæ·»åŠ çº¢è‰²å…‰ç¯
                const pulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
                ctx.strokeStyle = `rgba(255, 0, 0, ${pulse})`;
                ctx.lineWidth = 8;
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(boss.x + boss.width/2, boss.y + boss.height/2, boss.width/2 + 30, 0, Math.PI * 2);
                ctx.stroke();
            } else if (boss.phase === 3) {
                // ç¬¬ä¸‰é˜¶æ®µ - æœ€ç»ˆçŠ¶æ€ï¼Œæ·»åŠ æ—‹è½¬æ•ˆæœ
                ctx.save();
                ctx.translate(boss.x + boss.width/2, boss.y + boss.height/2);
                ctx.rotate(Date.now() / 500);
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 20;
                for (let i = 0; i < 6; i++) {
                    ctx.save();
                    ctx.rotate(i * Math.PI / 3);
                    ctx.fillRect(-20, -20, 40, 40);
                    ctx.restore();
                }
                ctx.restore();
            }
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶å­å¼¹
        function drawBullets() {
            // ç»˜åˆ¶ç©å®¶å­å¼¹
            player.bullets.forEach(bullet => {
                ctx.save();
                
                // ç‹‚çƒ­æ¨¡å¼å­å¼¹ç‰¹æ•ˆ
                if (frenzyMode) {
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                } else if (bullet.explosive) {
                    ctx.fillStyle = '#ffaa00';
                    ctx.shadowColor = '#ffaa00';
                } else {
                    ctx.fillStyle = '#00ffaa';
                    ctx.shadowColor = '#00ffaa';
                }
                
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸‰è¿å‘å­å¼¹çš„é¢å¤–æ•ˆæœ
                if (player.tripleShot) {
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                ctx.restore();
            });
            
            // ç»˜åˆ¶æ•Œäººå­å¼¹
            enemyBullets.forEach(bullet => {
                ctx.save();
                
                ctx.fillStyle = bullet.color || '#aa55ff';
                ctx.shadowColor = bullet.color || '#aa55ff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }
        
        // ç»˜åˆ¶ç²’å­æ•ˆæœ
        function drawParticles() {
            particles.forEach((particle, index) => {
                ctx.save();
                
                ctx.globalAlpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color;
                
                if (particle.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (particle.type === 'square') {
                    ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                } else if (particle.type === 'star') {
                    // ç»˜åˆ¶æ˜Ÿå½¢ç²’å­
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5;
                        const radius = particle.size;
                        ctx.lineTo(
                            particle.x + Math.cos(angle) * radius,
                            particle.y + Math.sin(angle) * radius
                        );
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
                
                // æ›´æ–°ç²’å­
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                // ç§»é™¤æ­»äº¡ç²’å­
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });
        }
        
        // ç»˜åˆ¶æ— äººæœº
        function drawDrones() {
            if (!abilities.drone.active) return;
            
            abilities.drone.drones.forEach(drone => {
                ctx.save();
                
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(drone.x, drone.y, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶æ— äººæœºè£…é¥°
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(drone.x, drone.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶æ—‹è½¬æ•ˆæœ
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(drone.x, drone.y, 12, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            });
        }
        
        // ç§»åŠ¨ç©å®¶
        function movePlayer() {
            let moveX = 0;
            let moveY = 0;
            
            // æ£€æŸ¥æŒ‰é”®
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveX -= player.speed;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) moveX += player.speed;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) moveY -= player.speed;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) moveY += player.speed;
            
            // å¯¹è§’çº¿ç§»åŠ¨é€Ÿåº¦ä¿®æ­£
            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.7071;
                moveY *= 0.7071;
            }
            
            // åº”ç”¨ç§»åŠ¨
            player.x += moveX;
            player.y += moveY;
            
            // è¾¹ç•Œæ£€æŸ¥
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
            
            // ç”Ÿå‘½æ¢å¤
            if (player.regenHealth && health < maxHealth) {
                health += player.regenRate;
                if (health > maxHealth) health = maxHealth;
                updateUI();
            }
        }
        
        // ç§»åŠ¨æ•Œäºº
        function moveEnemies() {
            enemies.forEach((enemy, enemyIndex) => {
                // è®°å½•æ®‹å½±ä½ç½®ï¼ˆä»…å¯¹å¿«é€Ÿæ•Œäººï¼‰
                if (enemy.type === 'fast') {
                    enemy.trail.push({x: enemy.x, y: enemy.y});
                    if (enemy.trail.length > 5) {
                        enemy.trail.shift();
                    }
                }
                
                // è®¡ç®—æŒ‡å‘ç©å®¶çš„æ–¹å‘
                const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
                const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // ç§»åŠ¨æ•Œäºº
                if (distance > 0 && !timeStopActive) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
                
                // è¿œç¨‹æ•Œäººå°„å‡»
                if (enemy.type === 'shooter') {
                    const now = Date.now();
                    if (now - enemy.lastShot > enemy.shotDelay && distance < enemy.range && !timeStopActive) {
                        shootEnemy(enemy);
                        enemy.lastShot = now;
                    }
                }
                
                // å¬å”¤æ•Œäººå¬å”¤
                if (enemy.type === 'summoner') {
                    const now = Date.now();
                    if (now - enemy.lastSummon > enemy.summonDelay && !timeStopActive) {
                        // å¬å”¤ä¸¤ä¸ªæ–°æ•Œäºº
                        for (let i = 0; i < 2; i++) {
                            const newEnemy = {
                                x: enemy.x + enemy.width/2,
                                y: enemy.y + enemy.height/2,
                                width: 30,
                                height: 30,
                                health: 100,
                                maxHealth: 100,
                                speed: 2,
                                color: '#ff8888',
                                type: 'normal'
                            };
                            enemies.push(newEnemy);
                            enemiesRemaining++;
                        }
                        enemy.lastSummon = now;
                    }
                }
                
                // æ£€æŸ¥æ•Œäººæ˜¯å¦ä¸ç©å®¶ç¢°æ’
                if (!abilities.shield.active && !godMode &&
                    enemy.x < player.x + player.width &&
                    enemy.x + enemy.width > player.x &&
                    enemy.y < player.y + player.height &&
                    enemy.y + enemy.height > player.y) {
                    
                    // é—ªé¿åˆ¤å®š
                    if (Math.random() * 100 > player.dodgeChance) {
                        // æ•Œäººç¢°æ’ä¼¤å®³
                        health -= enemy.type === 'tank' ? 20 : 10;
                        updateUI();
                        
                        // åˆ›å»ºç¢°æ’ç²’å­
                        createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 15, '#ff0000');
                        
                        // æ£€æŸ¥æ¸¸æˆç»“æŸ
                        if (health <= 0) {
                            health = 0;
                            endGame();
                        }
                    }
                    
                    // ç§»é™¤æ•Œäºº
                    enemies.splice(enemyIndex, 1);
                    enemiesRemaining--;
                    
                    // é‡ç½®è¿å‡»
                    resetCombo();
                }
            });
            
            // ç§»åŠ¨Boss
            if (boss && !timeStopActive) {
                moveBoss();
            }
        }
        
        // ç§»åŠ¨Boss
        function moveBoss() {
            // Bossæ°´å¹³ç§»åŠ¨
            boss.x += boss.speed * boss.moveDirection;
            
            // Bossè¾¹ç•Œæ£€æŸ¥å¹¶åå¼¹
            if (boss.x <= 0 || boss.x + boss.width >= canvas.width) {
                boss.moveDirection *= -1;
                boss.x = Math.max(0, Math.min(canvas.width - boss.width, boss.x));
            }
            
            // Bosså‚ç›´æµ®åŠ¨
            boss.y = 100 + Math.sin(Date.now() / 1800) * 50;
            
            // Bossé˜¶æ®µåˆ‡æ¢
            const now = Date.now();
            if (now - boss.lastPhaseChange > boss.phaseChangeDelay) {
                boss.phase++;
                boss.lastPhaseChange = now;
                
                // ç¬¬ä¸‰é˜¶æ®µåé‡ç½®åˆ°ç¬¬ä¸€é˜¶æ®µ
                if (boss.phase > 3) boss.phase = 1;
                
                // æ ¹æ®é˜¶æ®µè°ƒæ•´Bossè¡Œä¸º
                if (boss.phase === 2) {
                    // ç¬¬äºŒé˜¶æ®µï¼šæ›´å¿«å°„å‡»
                    boss.shotDelay = 500;
                    boss.speed = 2.5;
                } else if (boss.phase === 3) {
                    // ç¬¬ä¸‰é˜¶æ®µï¼šæ‰‡å½¢å°„å‡»
                    boss.shotDelay = 300;
                    boss.speed = 3.5;
                } else {
                    // ç¬¬ä¸€é˜¶æ®µï¼šæ­£å¸¸è¡Œä¸º
                    boss.shotDelay = 800;
                    boss.speed = 1.5;
                }
            }
            
            // æ”»å‡»æ¨¡å¼åˆ‡æ¢
            if (now - boss.lastPatternChange > boss.patternChangeDelay) {
                boss.pattern = (boss.pattern + 1) % 4;
                boss.lastPatternChange = now;
            }
            
            // Bosså°„å‡»
            if (now - boss.lastShot > boss.shotDelay) {
                shootBoss();
                boss.lastShot = now;
            }
        }
        
        // æ•Œäººå°„å‡»
        function shootEnemy(enemy) {
            const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
            const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) return;
            
            const bullet = {
                x: enemy.x + enemy.width/2,
                y: enemy.y + enemy.height/2,
                radius: 8,
                speed: 6,
                vx: dx / distance,
                vy: dy / distance,
                damage: 15,
                color: '#aa55ff'
            };
            
            enemyBullets.push(bullet);
        }
        
        // Bosså°„å‡»ï¼ˆå¤šç§æ”»å‡»æ¨¡å¼ï¼‰
        function shootBoss() {
            const centerX = boss.x + boss.width/2;
            const centerY = boss.y + boss.height/2;
            
            if (boss.pattern === 0) {
                // æ¨¡å¼0ï¼šç®€å•ç„å‡†å°„å‡»
                const dx = (player.x + player.width/2) - centerX;
                const dy = (player.y + player.height/2) - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance === 0) return;
                
                enemyBullets.push({
                    x: centerX,
                    y: centerY,
                    radius: 15,
                    speed: 7,
                    vx: dx / distance,
                    vy: dy / distance,
                    damage: 25,
                    color: '#ff00ff'
                });
            } else if (boss.pattern === 1) {
                // æ¨¡å¼1ï¼šä¸‰å‘å­å¼¹
                for (let i = -1; i <= 1; i++) {
                    const angle = Math.atan2(
                        player.y + player.height/2 - centerY,
                        player.x + player.width/2 - centerX
                    ) + i * 0.3;
                    
                    enemyBullets.push({
                        x: centerX,
                        y: centerY,
                        radius: 12,
                        speed: 8,
                        vx: Math.cos(angle),
                        vy: Math.sin(angle),
                        damage: 20,
                        color: '#ff55ff'
                    });
                }
            } else if (boss.pattern === 2) {
                // æ¨¡å¼2ï¼šæ‰‡å½¢å­å¼¹
                for (let i = 0; i < 12; i++) {
                    const angle = (Math.PI * 2 * i / 12) + Date.now() / 1000;
                    
                    enemyBullets.push({
                        x: centerX,
                        y: centerY,
                        radius: 10,
                        speed: 9,
                        vx: Math.cos(angle),
                        vy: Math.sin(angle),
                        damage: 15,
                        color: '#ff88ff'
                    });
                }
            } else if (boss.pattern === 3) {
                // æ¨¡å¼3ï¼šèºæ—‹å­å¼¹
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i / 8) + Date.now() / 500;
                    
                    enemyBullets.push({
                        x: centerX,
                        y: centerY,
                        radius: 8,
                        speed: 10,
                        vx: Math.cos(angle),
                        vy: Math.sin(angle),
                        damage: 12,
                        color: '#ffaaff'
                    });
                }
            }
        }
        
        // ç©å®¶å°„å‡»ï¼ˆå¤§å¹…å¢å¼ºï¼‰
        function shootPlayer() {
            const now = Date.now();
            if (now - player.lastShot < player.shotDelay) return;
            
            player.lastShot = now;
            
            // è®¡ç®—å°„å‡»æ–¹å‘ï¼ˆæœå‘é¼ æ ‡ï¼‰
            const dx = mouse.x - (player.x + player.width/2);
            const dy = mouse.y - (player.y + player.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) return;
            
            // åŸºç¡€æ–¹å‘
            const baseVx = dx / distance;
            const baseVy = dy / distance;
            
            // è®¡ç®—å®é™…ä¼¤å®³ï¼ˆè¿å‡»åŠ æˆï¼‰
            const actualDamage = player.damage * (1 + combo / 100);
            
            // å‘å°„å­å¼¹
            for (let i = 0; i < player.bulletCount; i++) {
                // ä¸‰è¿å‘å­å¼¹çš„è§’åº¦åç§»
                let angleOffset = 0;
                if (player.tripleShot && i < 3) {
                    angleOffset = (i - 1) * 0.1; // å·¦ã€ä¸­ã€å³ä¸‰å‘
                }
                
                // è®¡ç®—å­å¼¹æ–¹å‘
                let bulletVx, bulletVy;
                if (angleOffset !== 0) {
                    const angle = Math.atan2(baseVy, baseVx) + angleOffset;
                    bulletVx = Math.cos(angle);
                    bulletVy = Math.sin(angle);
                } else {
                    bulletVx = baseVx;
                    bulletVy = baseVy;
                }
                
                // è‡ªåŠ¨è¿½è¸ªä¿®æ­£
                if (player.homing && frenzyMode) {
                    // æ‰¾åˆ°æœ€è¿‘çš„æ•Œäºº
                    let nearestEnemy = null;
                    let nearestDistance = Infinity;
                    
                    enemies.forEach(enemy => {
                        const edx = (enemy.x + enemy.width/2) - (player.x + player.width/2);
                        const edy = (enemy.y + enemy.height/2) - (player.y + player.height/2);
                        const edistance = Math.sqrt(edx * edx + edy * edy);
                        
                        if (edistance < nearestDistance && edistance < 500) {
                            nearestDistance = edistance;
                            nearestEnemy = enemy;
                        }
                    });
                    
                    if (nearestEnemy) {
                        const targetDx = (nearestEnemy.x + nearestEnemy.width/2) - (player.x + player.width/2);
                        const targetDy = (nearestEnemy.y + nearestEnemy.height/2) - (player.y + player.height/2);
                        const targetDistance = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                        
                        if (targetDistance > 0) {
                            // è½»å¾®è¿½è¸ªæ•ˆæœ
                            bulletVx = (bulletVx * 0.7 + targetDx / targetDistance * 0.3);
                            bulletVy = (bulletVy * 0.7 + targetDy / targetDistance * 0.3);
                            
                            // å½’ä¸€åŒ–
                            const bulletSpeed = Math.sqrt(bulletVx * bulletVx + bulletVy * bulletVy);
                            bulletVx /= bulletSpeed;
                            bulletVy /= bulletSpeed;
                        }
                    }
                }
                
                const bullet = {
                    x: player.x + player.width/2,
                    y: player.y + player.height/2,
                    radius: 8 * player.attackRange,
                    speed: 12,
                    vx: bulletVx,
                    vy: bulletVy,
                    damage: actualDamage,
                    pierce: player.pierce,
                    piercedEnemies: 0,
                    explosive: player.explosive,
                    homing: player.homing
                };
                
                player.bullets.push(bullet);
            }
            
            // è¿å‘æ•ˆæœï¼šå¦‚æœå°„é€Ÿè¶³å¤Ÿå¿«ï¼Œå¯ä»¥å†æ¬¡è§¦å‘
            if (player.shotDelay < 50) {
                setTimeout(() => {
                    if (gameRunning && !gamePaused) {
                        shootPlayer();
                    }
                }, player.shotDelay / 2);
            }
        }
        
        // åˆ›å»ºç²’å­æ•ˆæœ
        function createParticles(x, y, count, color, type = 'circle') {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: Math.random() * 8 + 3,
                    color: color || '#ffffff',
                    life: Math.random() * 40 + 30,
                    maxLife: 70,
                    type: type
                });
            }
        }
        
        // å¢åŠ è¿å‡»
        function addCombo() {
            combo++;
            if (combo > maxCombo) maxCombo = combo;
            
            // æ¯10è¿å‡»æ˜¾ç¤ºæç¤º
            if (combo % 10 === 0) {
                showPowerupIndicator(`è¿å‡» ${combo}ï¼`);
            }
            
            // è¿›å…¥ç‹‚çƒ­æ¨¡å¼
            if (combo >= 50 && !frenzyMode) {
                frenzyMode = true;
                showPowerupIndicator("ç‹‚çƒ­æ¨¡å¼ï¼");
                
                // ç‹‚çƒ­æ¨¡å¼æ•ˆæœï¼šæ”»å‡»èŒƒå›´æ‰©å¤§ï¼Œè‡ªåŠ¨è¿½è¸ª
                player.attackRange = 1.5;
                player.homing = true;
                
                // 10ç§’åé€€å‡ºç‹‚çƒ­æ¨¡å¼
                setTimeout(() => {
                    if (combo < 50) {
                        frenzyMode = false;
                        player.attackRange = 1.0;
                        player.homing = false;
                    }
                }, 10000);
            }
            
            // é‡ç½®è¿å‡»è¶…æ—¶
            clearTimeout(comboTimeout);
            comboTimeout = setTimeout(() => {
                if (combo > 0) {
                    combo = 0;
                    frenzyMode = false;
                    player.attackRange = 1.0;
                    player.homing = false;
                    updateUI();
                }
            }, 3000);
            
            updateUI();
        }
        
        // é‡ç½®è¿å‡»
        function resetCombo() {
            if (combo > 0) {
                combo = 0;
                frenzyMode = false;
                player.attackRange = 1.0;
                player.homing = false;
                updateUI();
            }
        }
        
        // æ˜¾ç¤ºå¼ºåŒ–æç¤º
        function showPowerupIndicator(text) {
            const indicator = document.getElementById('powerup-indicator');
            indicator.textContent = text;
            indicator.style.display = 'block';
            
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 2000);
        }
        
        // è‡ªåŠ¨é‡Šæ”¾æŠ€èƒ½
        function autoCastSkills() {
            if (!autoSkills || !gameRunning || gamePaused) return;
            
            const now = Date.now();
            
            // æ£€æŸ¥æ¯ä¸ªæŠ€èƒ½æ˜¯å¦å¯ä»¥è‡ªåŠ¨é‡Šæ”¾
            for (let abilityKey in abilities) {
                const ability = abilities[abilityKey];
                
                // å¦‚æœæŠ€èƒ½è®¾ç½®äº†è‡ªåŠ¨é‡Šæ”¾ä¸”å†·å´å®Œæ¯•
                if (ability.auto && now - ability.lastUsed > ability.cooldown) {
                    // æ ¹æ®æŠ€èƒ½ç±»å‹å†³å®šé‡Šæ”¾æ¡ä»¶
                    let shouldCast = false;
                    
                    if (abilityKey === 'chainLightning') {
                        // ç”µç£ç‚®ï¼šæœ‰æ•Œäººæ—¶é‡Šæ”¾
                        shouldCast = enemies.length > 3;
                    } else if (abilityKey === 'shield') {
                        // æŠ¤ç›¾ï¼šç”Ÿå‘½å€¼ä½äº50%æ—¶é‡Šæ”¾
                        shouldCast = health < maxHealth * 0.5;
                    } else if (abilityKey === 'bomb') {
                        // é»‘æ´ç‚¸å¼¹ï¼šæ•Œäººæ•°é‡å¤šæ—¶é‡Šæ”¾
                        shouldCast = enemies.length > 5 || (boss && boss.health < boss.maxHealth * 0.3);
                    } else if (abilityKey === 'drone') {
                        // æµ®æ¸¸ç‚®ï¼šæ²¡æœ‰æ¿€æ´»çš„æ— äººæœºæ—¶é‡Šæ”¾
                        shouldCast = !ability.active;
                    } else if (abilityKey === 'timeStop') {
                        // æ—¶é—´åœæ»ï¼šè¢«å¤§é‡å­å¼¹åŒ…å›´æ—¶é‡Šæ”¾
                        shouldCast = enemyBullets.length > 20;
                    }
                    
                    if (shouldCast) {
                        // è§¦å‘æŠ€èƒ½
                        if (abilityKey === 'chainLightning') useChainLightning();
                        else if (abilityKey === 'shield') useShield();
                        else if (abilityKey === 'bomb') useBomb();
                        else if (abilityKey === 'drone') useDrone();
                        else if (abilityKey === 'timeStop') useTimeStop();
                    }
                }
            }
        }
        
        // ä½¿ç”¨æŠ€èƒ½ï¼šè¶…ç”µç£ç‚®
        function useChainLightning() {
            const now = Date.now();
            if (now - abilities.chainLightning.lastUsed < abilities.chainLightning.cooldown) return;
            
            abilities.chainLightning.lastUsed = now;
            abilities.chainLightning.active = true;
            
            // æ‰¾åˆ°æ‰€æœ‰æ•Œäºº
            const targetEnemies = [...enemies];
            if (boss) targetEnemies.push(boss);
            
            if (targetEnemies.length === 0) return;
            
            // å¯¹æ•Œäººé€ æˆè¿é”ä¼¤å®³
            let currentTarget = targetEnemies[0];
            let chainCount = 5 + playerLevel * 2;
            
            for (let i = 0; i < chainCount && currentTarget; i++) {
                // å¯¹æ•Œäººé€ æˆä¼¤å®³
                const damage = 100 + playerLevel * 20;
                const actualDamage = currentTarget.damageReduction ? damage * (1 - currentTarget.damageReduction) : damage;
                currentTarget.health -= actualDamage;
                
                // åˆ›å»ºé—ªç”µç²’å­
                createParticles(currentTarget.x + currentTarget.width/2, currentTarget.y + currentTarget.height/2, 25, '#00ffff', 'star');
                
                // ç»˜åˆ¶é—ªç”µæ•ˆæœ
                if (i > 0) {
                    const prevTarget = targetEnemies[i-1] || {x: player.x, y: player.y, width: 0, height: 0};
                    drawLightning(
                        prevTarget.x + prevTarget.width/2, 
                        prevTarget.y + prevTarget.height/2,
                        currentTarget.x + currentTarget.width/2, 
                        currentTarget.y + currentTarget.height/2
                    );
                }
                
                // å¦‚æœæ•Œäººæ­»äº¡ï¼Œå¢åŠ åˆ†æ•°å’Œç»éªŒ
                if (currentTarget.health <= 0) {
                    score += 100;
                    xp += 50;
                    enemiesRemaining--;
                    
                    // ä»æ•°ç»„ä¸­ç§»é™¤æ•Œäººï¼ˆå¦‚æœä¸æ˜¯Bossï¼‰
                    if (currentTarget !== boss) {
                        const index = enemies.indexOf(currentTarget);
                        if (index > -1) enemies.splice(index, 1);
                    } else {
                        defeatBoss();
                    }
                }
                
                // æ‰¾åˆ°ä¸‹ä¸€ä¸ªæœ€è¿‘çš„æ•Œäººï¼ˆç”¨äºè¿é”ï¼‰
                let nextTarget = null;
                let nextDistance = Infinity;
                
                targetEnemies.forEach(enemy => {
                    if (enemy === currentTarget || enemy.health <= 0) return;
                    
                    const dx = enemy.x - currentTarget.x;
                    const dy = enemy.y - currentTarget.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < nextDistance && distance < 300) {
                        nextDistance = distance;
                        nextTarget = enemy;
                    }
                });
                
                currentTarget = nextTarget;
            }
            
            // å¢åŠ è¿å‡»
            addCombo();
            
            // æ›´æ–°UI
            updateUI();
            
            // æ£€æŸ¥å‡çº§
            checkLevelUp();
        }
        
        // ç»˜åˆ¶é—ªç”µæ•ˆæœ
        function drawLightning(x1, y1, x2, y2) {
            ctx.save();
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20;
            
            // åˆ›å»ºé—ªç”µè·¯å¾„
            const segments = 8;
            const points = [{x: x1, y: y1}];
            
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const x = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 30;
                const y = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 30;
                points.push({x, y});
            }
            
            points.push({x: x2, y: y2});
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            
            ctx.stroke();
            ctx.restore();
        }
        
        // ä½¿ç”¨æŠ€èƒ½ï¼šç»å¯¹é˜²å¾¡
        function useShield() {
            const now = Date.now();
            if (now - abilities.shield.lastUsed < abilities.shield.cooldown) return;
            
            abilities.shield.lastUsed = now;
            abilities.shield.active = true;
            
            // 4ç§’åæŠ¤ç›¾æ¶ˆå¤±
            setTimeout(() => {
                abilities.shield.active = false;
            }, abilities.shield.duration);
        }
        
        // ä½¿ç”¨æŠ€èƒ½ï¼šé»‘æ´ç‚¸å¼¹
        function useBomb() {
            const now = Date.now();
            if (now - abilities.bomb.lastUsed < abilities.bomb.cooldown) return;
            
            abilities.bomb.lastUsed = now;
            
            // å¯¹å±å¹•ä¸Šçš„æ‰€æœ‰æ•Œäººé€ æˆä¼¤å®³å¹¶å¸èš
            enemies.forEach(enemy => {
                // å¸èšæ•ˆæœï¼šå°†æ•Œäººæ‹‰å‘ä¸­å¿ƒ
                const dx = (canvas.width/2) - (enemy.x + enemy.width/2);
                const dy = (canvas.height/2) - (enemy.y + enemy.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    enemy.x += dx / distance * 10;
                    enemy.y += dy / distance * 10;
                }
                
                // é€ æˆä¼¤å®³
                const damage = 200 + playerLevel * 50;
                const actualDamage = enemy.damageReduction ? damage * (1 - enemy.damageReduction) : damage;
                enemy.health -= actualDamage;
                
                // åˆ›å»ºé»‘æ´ç²’å­
                createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 30, '#000000', 'circle');
                
                // å¦‚æœæ•Œäººæ­»äº¡ï¼Œå¢åŠ åˆ†æ•°å’Œç»éªŒ
                if (enemy.health <= 0) {
                    score += 150;
                    xp += 75;
                    enemiesRemaining--;
                    
                    // ä»æ•°ç»„ä¸­ç§»é™¤æ•Œäºº
                    const index = enemies.indexOf(enemy);
                    if (index > -1) enemies.splice(index, 1);
                }
            });
            
            // å¯¹Bossé€ æˆä¼¤å®³
            if (boss) {
                const damage = 500 + playerLevel * 100;
                boss.health -= damage;
                updateBossHealthBar();
                
                createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 80, '#000000', 'circle');
                
                // æ£€æŸ¥Bossæ˜¯å¦æ­»äº¡
                if (boss.health <= 0) {
                    defeatBoss();
                }
            }
            
            // å¢åŠ è¿å‡»
            addCombo();
            
            // æ›´æ–°UI
            updateUI();
            
            // æ£€æŸ¥å‡çº§
            checkLevelUp();
        }
        
        // ä½¿ç”¨æŠ€èƒ½ï¼šæµ®æ¸¸ç‚®
        function useDrone() {
            const now = Date.now();
            if (now - abilities.drone.lastUsed < abilities.drone.cooldown) return;
            
            abilities.drone.lastUsed = now;
            abilities.drone.active = true;
            
            // æ¸…é™¤ç°æœ‰æ— äººæœº
            abilities.drone.drones = [];
            
            // åˆ›å»º4æ¶æ— äººæœº
            for (let i = 0; i < 4; i++) {
                abilities.drone.drones.push({
                    x: player.x + (i - 1.5) * 60,
                    y: player.y - 50,
                    angle: 0,
                    lastShot: 0,
                    shotDelay: 400 // æ›´å¿«çš„å°„å‡»
                });
            }
            
            // 25ç§’åæ— äººæœºæ¶ˆå¤±
            setTimeout(() => {
                abilities.drone.active = false;
                abilities.drone.drones = [];
            }, 25000);
        }
        
        // ä½¿ç”¨æŠ€èƒ½ï¼šæ—¶é—´åœæ»
        function useTimeStop() {
            const now = Date.now();
            if (now - abilities.timeStop.lastUsed < abilities.timeStop.cooldown) return;
            
            abilities.timeStop.lastUsed = now;
            timeStopActive = true;
            timeStopEnd = now + abilities.timeStop.duration;
            
            // 3ç§’åæ—¶é—´æ¢å¤
            setTimeout(() => {
                timeStopActive = false;
            }, abilities.timeStop.duration);
        }
        
        // æ›´æ–°æ— äººæœº
        function updateDrones() {
            if (!abilities.drone.active) return;
            
            const now = Date.now();
            
            abilities.drone.drones.forEach((drone, index) => {
                // æ— äººæœºå›´ç»•ç©å®¶æ—‹è½¬
                drone.angle += 0.03;
                const radius = 100;
                drone.x = player.x + player.width/2 + Math.cos(drone.angle + index * Math.PI * 2/4) * radius;
                drone.y = player.y + player.height/2 + Math.sin(drone.angle + index * Math.PI * 2/4) * radius;
                
                // æ— äººæœºå°„å‡»
                if (now - drone.lastShot > drone.shotDelay && !timeStopActive) {
                    // æ‰¾åˆ°æœ€è¿‘çš„æ•Œäºº
                    let nearestEnemy = null;
                    let nearestDistance = Infinity;
                    
                    enemies.forEach(enemy => {
                        const dx = enemy.x - drone.x;
                        const dy = enemy.y - drone.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < nearestDistance && distance < 400) {
                            nearestDistance = distance;
                            nearestEnemy = enemy;
                        }
                    });
                    
                    if (nearestEnemy) {
                        // è®¡ç®—å°„å‡»æ–¹å‘
                        const dx = nearestEnemy.x + nearestEnemy.width/2 - drone.x;
                        const dy = nearestEnemy.y + nearestEnemy.height/2 - drone.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            // å‘å°„æ— äººæœºå­å¼¹
                            player.bullets.push({
                                x: drone.x,
                                y: drone.y,
                                radius: 6,
                                speed: 12,
                                vx: dx / distance,
                                vy: dy / distance,
                                damage: player.damage * 0.8,
                                pierce: 1,
                                piercedEnemies: 0,
                                explosive: false
                            });
                            
                            drone.lastShot = now;
                        }
                    }
                }
            });
        }
        
        // æ›´æ–°å­å¼¹
        function updateBullets() {
            // æ›´æ–°ç©å®¶å­å¼¹
            for (let i = player.bullets.length - 1; i >= 0; i--) {
                const bullet = player.bullets[i];
                
                // ç§»åŠ¨å­å¼¹
                if (!timeStopActive) {
                    bullet.x += bullet.vx * bullet.speed;
                    bullet.y += bullet.vy * bullet.speed;
                }
                
                // ç§»é™¤è¶…å‡ºç”»å¸ƒçš„å­å¼¹
                if (bullet.x < -bullet.radius || bullet.x > canvas.width + bullet.radius ||
                    bullet.y < -bullet.radius || bullet.y > canvas.height + bullet.radius) {
                    player.bullets.splice(i, 1);
                    continue;
                }
                
                // æ£€æŸ¥å­å¼¹æ˜¯å¦å‡»ä¸­æ•Œäºº
                let hitEnemy = false;
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    if (bullet.x > enemy.x && bullet.x < enemy.x + enemy.width &&
                        bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {
                        
                        // å¯¹æ•Œäººé€ æˆä¼¤å®³
                        const actualDamage = enemy.damageReduction ? 
                            bullet.damage * (1 - enemy.damageReduction) : bullet.damage;
                        enemy.health -= actualDamage;
                        
                        // çˆ†ç‚¸å­å¼¹æ•ˆæœ
                        if (bullet.explosive) {
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 25, '#ffaa00', 'star');
                            
                            // å¯¹é™„è¿‘æ•Œäººé€ æˆæº…å°„ä¼¤å®³
                            enemies.forEach(otherEnemy => {
                                if (otherEnemy === enemy) return;
                                
                                const dx = otherEnemy.x - enemy.x;
                                const dy = otherEnemy.y - enemy.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < 100) {
                                    const splashDamage = bullet.damage * 0.7;
                                    const actualSplashDamage = otherEnemy.damageReduction ? 
                                        splashDamage * (1 - otherEnemy.damageReduction) : splashDamage;
                                    otherEnemy.health -= actualSplashDamage;
                                }
                            });
                        } else {
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 10, '#00ffaa', 'circle');
                        }
                        
                        // å¢åŠ è¿å‡»
                        addCombo();
                        
                        // å¦‚æœæ•Œäººæ­»äº¡ï¼Œå¢åŠ åˆ†æ•°å’Œç»éªŒ
                        if (enemy.health <= 0) {
                            score += 20 * (enemy.type === 'tank' ? 5 : enemy.type === 'shooter' ? 3 : 1);
                            xp += 10 * (enemy.type === 'tank' ? 3 : 1);
                            enemiesRemaining--;
                            
                            // åˆ†è£‚æ•Œäººç‰¹æ®Šå¤„ç†
                            if (enemy.type === 'splitter') {
                                // åˆ†è£‚æˆä¸‰ä¸ªå°æ•Œäºº
                                for (let k = 0; k < 3; k++) {
                                    const smallEnemy = {
                                        x: enemy.x + enemy.width/2,
                                        y: enemy.y + enemy.height/2,
                                        width: 25,
                                        height: 25,
                                        health: 50,
                                        maxHealth: 50,
                                        speed: 3,
                                        color: '#55ff55',
                                        type: 'normal'
                                    };
                                    enemies.push(smallEnemy);
                                    enemiesRemaining++;
                                }
                            }
                            
                            // ä»æ•°ç»„ä¸­ç§»é™¤æ•Œäºº
                            enemies.splice(j, 1);
                        }
                        
                        // æ›´æ–°UI
                        updateUI();
                        
                        // æ£€æŸ¥ç©¿é€
                        bullet.piercedEnemies++;
                        if (bullet.pierce > 0 && bullet.piercedEnemies > bullet.pierce) {
                            player.bullets.splice(i, 1);
                            hitEnemy = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœå­å¼¹å‡»ä¸­æ•Œäººå¹¶ä¸”æ²¡æœ‰ç©¿é€äº†ï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªå­å¼¹
                if (hitEnemy) {
                    // æ£€æŸ¥å‡çº§
                    checkLevelUp();
                    continue;
                }
                
                // æ£€æŸ¥å­å¼¹æ˜¯å¦å‡»ä¸­Boss
                if (boss && bullet.x > boss.x && bullet.x < boss.x + boss.width &&
                    bullet.y > boss.y && bullet.y < boss.y + boss.height) {
                    
                    // å¯¹Bossé€ æˆä¼¤å®³
                    boss.health -= bullet.damage;
                    updateBossHealthBar();
                    
                    createParticles(bullet.x, bullet.y, 15, '#ff00ff', 'circle');
                    
                    // çˆ†ç‚¸å­å¼¹å¯¹Bossé€ æˆé¢å¤–ä¼¤å®³
                    if (bullet.explosive) {
                        boss.health -= bullet.damage * 0.5;
                        createParticles(bullet.x, bullet.y, 30, '#ffaa00', 'star');
                    }
                    
                    // å¢åŠ è¿å‡»
                    addCombo();
                    
                    // æ£€æŸ¥Bossæ˜¯å¦æ­»äº¡
                    if (boss.health <= 0) {
                        defeatBoss();
                    }
                    
                    player.bullets.splice(i, 1);
                    
                    // æ£€æŸ¥å‡çº§
                    checkLevelUp();
                }
            }
            
            // æ›´æ–°æ•Œäººå­å¼¹
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                
                // ç§»åŠ¨å­å¼¹
                if (!timeStopActive) {
                    bullet.x += bullet.vx * bullet.speed;
                    bullet.y += bullet.vy * bullet.speed;
                }
                
                // ç§»é™¤è¶…å‡ºç”»å¸ƒçš„å­å¼¹
                if (bullet.x < -bullet.radius || bullet.x > canvas.width + bullet.radius ||
                    bullet.y < -bullet.radius || bullet.y > canvas.height + bullet.radius) {
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                // æ£€æŸ¥å­å¼¹æ˜¯å¦å‡»ä¸­ç©å®¶
                if (!abilities.shield.active && !godMode &&
                    bullet.x > player.x && bullet.x < player.x + player.width &&
                    bullet.y > player.y && bullet.y < player.y + player.height) {
                    
                    // é—ªé¿åˆ¤å®š
                    if (Math.random() * 100 > player.dodgeChance) {
                        // å¯¹ç©å®¶é€ æˆä¼¤å®³
                        health -= bullet.damage;
                        enemyBullets.splice(i, 1);
                        
                        // åˆ›å»ºå‡»ä¸­ç²’å­
                        createParticles(bullet.x, bullet.y, 15, '#ff5555', 'circle');
                        
                        // æ›´æ–°UI
                        updateUI();
                        
                        // é‡ç½®è¿å‡»
                        resetCombo();
                        
                        // æ£€æŸ¥æ¸¸æˆç»“æŸ
                        if (health <= 0) {
                            health = 0;
                            endGame();
                        }
                    }
                }
                
                // å¦‚æœæŠ¤ç›¾æ¿€æ´»ï¼Œåå¼¹å­å¼¹
                if (abilities.shield.active &&
                    bullet.x > player.x - 30 && bullet.x < player.x + player.width + 30 &&
                    bullet.y > player.y - 30 && bullet.y < player.y + player.height + 30) {
                    
                    // è®¡ç®—åå¼¹æ–¹å‘
                    const dx = bullet.x - (player.x + player.width/2);
                    const dy = bullet.y - (player.y + player.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 60) {
                        // åå¼¹å­å¼¹
                        bullet.vx = dx / distance;
                        bullet.vy = dy / distance;
                        
                        // æ”¹å˜å­å¼¹é¢œè‰²ï¼ˆè¡¨ç¤ºå·²åå¼¹ï¼‰
                        bullet.color = '#00ffff';
                        
                        // åˆ›å»ºåå¼¹ç²’å­
                        createParticles(bullet.x, bullet.y, 8, '#00ffff', 'circle');
                    }
                }
            }
        }
        
        // å‡»è´¥Boss
        function defeatBoss() {
            // å¢åŠ å¤§é‡åˆ†æ•°å’Œç»éªŒ
            score += 1000 + wave * 200;
            xp += 500 + wave * 100;
            combo += 50; // Bossæˆ˜å¢åŠ å¤§é‡è¿å‡»
            
            // åˆ›å»ºåº†ç¥ç²’å­
            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 150, '#ffff00', 'star');
            
            // éšè—Bossè¡€æ¡
            document.getElementById('boss-health').style.display = 'none';
            
            // æ¸…é™¤Boss
            boss = null;
            bossActive = false;
            
            // æ›´æ–°UI
            updateUI();
            
            // æ£€æŸ¥å‡çº§
            checkLevelUp();
        }
        
        // æ£€æŸ¥æ˜¯å¦å‡çº§
        function checkLevelUp() {
            if (xp >= xpToNextLevel) {
                xp -= xpToNextLevel;
                playerLevel++;
                xpToNextLevel = Math.floor(xpToNextLevel * 1.3);
                
                // æ˜¾ç¤ºå‡çº§ç•Œé¢
                showUpgradeScreen();
                
                // æ›´æ–°UI
                updateUI();
            }
        }
        
        // æ˜¾ç¤ºå‡çº§ç•Œé¢
        function showUpgradeScreen() {
            gamePaused = true;
            document.getElementById('upgrade-screen').style.display = 'flex';
        }
        
        // åº”ç”¨å‡çº§ï¼ˆå¤§å¹…å¢å¼ºå‡çº§æ•ˆæœï¼‰
        function applyUpgrade(upgradeType) {
            const upgrade = upgrades[upgradeType];
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿç§¯åˆ†
            if (score < upgrade.cost) return;
            
            // æ‰£é™¤ç§¯åˆ†
            score -= upgrade.cost;
            
            // åº”ç”¨å‡çº§æ•ˆæœ
            switch(upgradeType) {
                case 'damage':
                    player.damage *= 2.0; // 100%æå‡
                    player.attackRange *= 1.2;
                    upgrade.level++;
                    upgrade.cost = Math.floor(upgrade.cost * 1.8);
                    break;
                case 'fireRate':
                    player.shotDelay *= 0.4; // 150%æå‡
                    player.bulletCount++;
                    upgrade.level++;
                    upgrade.cost = Math.floor(upgrade.cost * 1.8);
                    break;
                case 'health':
                    maxHealth *= 3.0; // 200%æå‡
                    health = maxHealth;
                    player.regenHealth = true;
                    player.regenRate = maxHealth * 0.01; // æ¯ç§’æ¢å¤1%
                    upgrade.level++;
                    upgrade.cost = Math.floor(upgrade.cost * 1.8);
                    break;
                case 'speed':
                    player.speed *= 2.0; // 100%æå‡
                    player.dodgeChance += 10; // å¢åŠ 10%é—ªé¿å‡ ç‡
                    upgrade.level++;
                    upgrade.cost = Math.floor(upgrade.cost * 1.8);
                    break;
                case 'pierce':
                    player.pierce = Infinity; // æ— é™ç©¿é€
                    upgrade.level++;
                    upgrade.cost = Math.floor(upgrade.cost * 3);
                    break;
                case 'explosive':
                    player.explosive = true;
                    player.damage *= 1.5; // é¢å¤–50%ä¼¤å®³
                    upgrade.level++;
                    upgrade.cost = Math.floor(upgrade.cost * 3);
                    break;
            }
            
            // æ›´æ–°UI
            updateUI();
            
            // éšè—å‡çº§ç•Œé¢
            document.getElementById('upgrade-screen').style.display = 'none';
            gamePaused = false;
            
            // å¦‚æœæ¸¸æˆæ­£åœ¨è¿è¡Œï¼Œç»§ç»­æ¸¸æˆå¾ªç¯
            if (gameRunning) {
                gameLoop = requestAnimationFrame(updateGame);
            }
        }
        
        // ç»˜åˆ¶æ¸¸æˆèƒŒæ™¯
        function drawBackground() {
            // ç»˜åˆ¶æ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000000');
            gradient.addColorStop(1, '#200050');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶åŠ¨æ€æ˜Ÿç©º
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            for (let i = 0; i < 80; i++) {
                const x = (i * 29 + Date.now() / 80) % canvas.width;
                const y = (i * 17 + Date.now() / 120) % canvas.height;
                const size = Math.sin(Date.now() / 800 + i) * 2 + 2;
                const alpha = Math.sin(Date.now() / 1000 + i) * 0.5 + 0.5;
                
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            // ç»˜åˆ¶æ³¢æ¬¡ä¿¡æ¯
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`æ³¢æ¬¡: ${wave}`, canvas.width / 2, 40);
            
            // ç»˜åˆ¶å‰©ä½™æ•Œäººæ•°é‡
            if (!bossActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.font = 'bold 25px Arial';
                ctx.fillText(`å‰©ä½™æ•Œäºº: ${enemiesRemaining}`, canvas.width / 2, 80);
            }
            
            // æ—¶é—´åœæ»æ•ˆæœ
            if (timeStopActive) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶æ—¶é—´åœæ»æ–‡å­—
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 60px Arial';
                ctx.fillText('æ—¶é—´åœæ»ï¼', canvas.width / 2, canvas.height / 2);
            }
        }
        
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function updateGame() {
            if (!gameRunning || gamePaused) return;
            
            // æ¸…é™¤ç”»å¸ƒ
            drawBackground();
            
            // ç§»åŠ¨æ¸¸æˆå…ƒç´ 
            movePlayer();
            moveEnemies();
            updateBullets();
            updateDrones();
            
            // è‡ªåŠ¨é‡Šæ”¾æŠ€èƒ½
            if (autoSkills) {
                autoCastSkills();
            }
            
            // ç»˜åˆ¶æ¸¸æˆå…ƒç´ 
            drawEnemies();
            drawPlayer();
            drawBullets();
            drawParticles();
            drawDrones();
            
            // å¦‚æœå½“å‰æ³¢æ¬¡æ•Œäººå…¨éƒ¨è¢«å‡»è´¥ï¼Œç”Ÿæˆä¸‹ä¸€æ³¢
            if (enemiesRemaining <= 0 && !bossActive) {
                wave++;
                spawnWave();
            }
            
            // æ›´æ–°æŠ€èƒ½å†·å´æ˜¾ç¤º
            updateAbilityCooldowns();
            
            // ç»§ç»­æ¸¸æˆå¾ªç¯
            gameLoop = requestAnimationFrame(updateGame);
        }
        
        // äº‹ä»¶ç›‘å¬
        document.addEventListener('keydown', function(e) {
            keys[e.key] = true;
            
            // ç©ºæ ¼é”®æˆ–é¼ æ ‡å·¦é”®å°„å‡»
            if ((e.key === ' ' || e.key === 'x') && gameRunning && !gamePaused) {
                shootPlayer();
                e.preventDefault();
            }
            
            // æŠ€èƒ½é”®
            if (e.key === 'q' || e.key === 'Q') useChainLightning();
            if (e.key === 'w' || e.key === 'W') useShield();
            if (e.key === 'e' || e.key === 'E') useBomb();
            if (e.key === 'r' || e.key === 'R') useDrone();
            if (e.key === 't' || e.key === 'T') useTimeStop();
            
            // è‡ªåŠ¨å°„å‡»æ¨¡å¼ï¼ˆæŒ‰ä½Zé”®ï¼‰
            if (e.key === 'z' || e.key === 'Z') {
                if (gameRunning && !gamePaused) {
                    shootPlayer();
                }
            }
        });
        
        document.addEventListener('keyup', function(e) {
            keys[e.key] = false;
        });
        
        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', function(e) {
            mouse.pressed = true;
            if (gameRunning && !gamePaused) {
                shootPlayer();
            }
        });
        
        canvas.addEventListener('mouseup', function() {
            mouse.pressed = false;
        });
        
        canvas.addEventListener('click', function(e) {
            if (gameRunning && !gamePaused) {
                shootPlayer();
            }
        });
        
        // è‡ªåŠ¨å°„å‡»ï¼ˆå½“é¼ æ ‡æŒ‰ä¸‹æ—¶è¿ç»­å°„å‡»ï¼‰
        setInterval(() => {
            if (mouse.pressed && gameRunning && !gamePaused) {
                shootPlayer();
            }
        }, player.shotDelay);
        
        // æŒ‰é’®äº‹ä»¶
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('pause-btn').addEventListener('click', pauseGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        document.getElementById('upgrade-btn').addEventListener('click', function() {
            if (gameRunning) {
                showUpgradeScreen();
            }
        });
        
        // å‡çº§é€‰é¡¹äº‹ä»¶
        document.getElementById('upgrade-damage').addEventListener('click', () => applyUpgrade('damage'));
        document.getElementById('upgrade-fire-rate').addEventListener('click', () => applyUpgrade('fireRate'));
        document.getElementById('upgrade-health').addEventListener('click', () => applyUpgrade('health'));
        document.getElementById('upgrade-speed').addEventListener('click', () => applyUpgrade('speed'));
        document.getElementById('upgrade-pierce').addEventListener('click', () => applyUpgrade('pierce'));
        document.getElementById('upgrade-explosive').addEventListener('click', () => applyUpgrade('explosive'));
        
        // è‡ªåŠ¨é‡Šæ”¾æŠ€èƒ½åˆ‡æ¢
        document.getElementById('auto-skills-toggle').addEventListener('change', function() {
            autoSkills = this.checked;
        });
        
        document.getElementById('skip-upgrade-btn').addEventListener('click', function() {
            document.getElementById('upgrade-screen').style.display = 'none';
            gamePaused = false;
            
            if (gameRunning) {
                gameLoop = requestAnimationFrame(updateGame);
            }
        });
        
        // æŠ€èƒ½è‡ªåŠ¨é‡Šæ”¾åˆ‡æ¢
        for (let i = 1; i <= 5; i++) {
            document.getElementById(`auto-toggle-${i}`).addEventListener('click', function(e) {
                e.stopPropagation();
                const abilityKey = Object.keys(abilities)[i-1];
                abilities[abilityKey].auto = !abilities[abilityKey].auto;
                updateAutoToggleDisplay();
            });
        }
        
        // æ¸¸æˆè¯´æ˜æŒ‰é’®
        document.getElementById('instructions-btn').addEventListener('click', function() {
            const panel = document.getElementById('instructions-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });
        
        // ä¸Šå¸æ¨¡å¼æŒ‰é’®
        document.getElementById('godmode-btn').addEventListener('click', function() {
            godMode = !godMode;
            if (godMode) {
                this.style.background = 'linear-gradient(to bottom, #ff0000, #cc0000)';
                this.textContent = 'ä¸Šå¸æ¨¡å¼(å¼€å¯)';
                health = Infinity;
            } else {
                this.style.background = 'linear-gradient(to bottom, #ff00ff, #aa00ff)';
                this.textContent = 'ä¸Šå¸æ¨¡å¼';
                health = maxHealth;
            }
            updateUI();
        });
        
        // ç§»åŠ¨æ§åˆ¶
        document.getElementById('mobile-left').addEventListener('touchstart', function() {
            keys['ArrowLeft'] = true;
        });
        document.getElementById('mobile-left').addEventListener('touchend', function() {
            keys['ArrowLeft'] = false;
        });
        
        document.getElementById('mobile-right').addEventListener('touchstart', function() {
            keys['ArrowRight'] = true;
        });
        document.getElementById('mobile-right').addEventListener('touchend', function() {
            keys['ArrowRight'] = false;
        });
        
        document.getElementById('mobile-up').addEventListener('touchstart', function() {
            keys['ArrowUp'] = true;
        });
        document.getElementById('mobile-up').addEventListener('touchend', function() {
            keys['ArrowUp'] = false;
        });
        
        document.getElementById('mobile-down').addEventListener('touchstart', function() {
            keys['ArrowDown'] = true;
        });
        document.getElementById('mobile-down').addEventListener('touchend', function() {
            keys['ArrowDown'] = false;
        });
        
        document.getElementById('mobile-shoot').addEventListener('touchstart', function() {
            mouse.pressed = true;
            if (gameRunning && !gamePaused) {
                shootPlayer();
            }
        });
        
        document.getElementById('mobile-shoot').addEventListener('touchend', function() {
            mouse.pressed = false;
        });
        
        document.getElementById('mobile-ability1').addEventListener('touchstart', function() {
            useChainLightning();
        });
        
        document.getElementById('mobile-ability2').addEventListener('touchstart', function() {
            useShield();
        });
        
        document.getElementById('mobile-ability3').addEventListener('touchstart', function() {
            useBomb();
        });
        
        // é˜²æ­¢ç§»åŠ¨è®¾å¤‡ä¸Šçš„é»˜è®¤è¡Œä¸º
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
        
        // åˆå§‹ç»˜åˆ¶
        drawBackground();
        drawPlayer();
        
        // æ›´æ–°UIåˆå§‹çŠ¶æ€
        updateUI();
    </script>
</body>
</html>