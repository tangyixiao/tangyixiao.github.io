<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KCM-æŒ–åœŸè±† 3.0 æ­£å¼ç‰ˆ - </title>
    <style>
        :root {
            --primary: #ff00ff;
            --secondary: #00ffff;
            --accent: #ffff00;
            --bg: #050010;
            --glass: rgba(255, 255, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; }
        
        body {
            background: radial-gradient(circle at center, #1a0033 0%, #050010 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            padding: 20px;
        }

        .game-header {
            width: 100%; max-width: 1100px; margin: 15px 0; padding: 20px;
            background: var(--glass); backdrop-filter: blur(20px);
            border-radius: 20px; border: 3px solid var(--primary);
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.4); text-align: center;
        }

        .game-title {
            font-size: 3.5rem; font-weight: 900;
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
            background-size: 200% auto; -webkit-background-clip: text;
            -webkit-text-fill-color: transparent; animation: shine 4s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes shine { to { background-position: 200% center; } }

        .hud {
            display: grid; grid-template-columns: repeat(5, 1fr) 3fr;
            gap: 15px; width: 1100px; margin-bottom: 20px;
            padding: 15px; background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px); border-radius: 15px;
            border: 2px solid var(--primary);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
        }

        .hud-item {
            background: rgba(30, 0, 60, 0.8); padding: 15px; border-radius: 12px;
            border: 2px solid var(--secondary); text-align: center;
            backdrop-filter: blur(5px); 
        }

        .hud-value { 
            font-size: 2.2rem; font-weight: bold; color: var(--secondary); 
            text-shadow: 0 0 15px var(--secondary); margin-bottom: 5px;
            animation: valuePulse 2s infinite;
        }

        @keyframes valuePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .hud-label { font-size: 0.9rem; color: #aaa; text-transform: uppercase; }

        .ability-bar {
            display: flex; justify-content: space-between; align-items: center;
            gap: 10px; grid-column: 6;
        }

        .ability {
            width: 70px; height: 70px; border-radius: 15px;
            background: rgba(50, 20, 80, 0.9); border: 3px solid var(--primary);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; cursor: pointer; transition: all 0.2s;
            position: relative; overflow: hidden; backdrop-filter: blur(5px);
        }

        .ability:hover {
            transform: scale(1.1); border-color: var(--secondary);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
        }

        .ability-icon { font-size: 1.8rem; margin-bottom: 5px; }
        .ability-key { font-size: 0.9rem; color: #ffff00; background: rgba(0,0,0,0.7); padding: 3px 6px; border-radius: 5px; }

        .ability-cooldown {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(255, 0, 0, 0.8); transition: height 0.1s;
        }

        .auto-toggle {
            position: absolute; top: 5px; right: 5px; width: 15px; height: 15px;
            border-radius: 50%; background: #555; border: 2px solid #fff;
            cursor: pointer; transition: all 0.3s;
        }

        .auto-toggle.active { background: #00ff00; box-shadow: 0 0 10px #00ff00; }

        .game-container {
            position: relative; width: 1100px; height: 650px;
            background: rgba(5, 0, 16, 0.7) !important; border-radius: 20px;
            border: 3px solid var(--primary); box-shadow: 0 0 40px rgba(0,0,0,0.8), inset 0 0 20px rgba(255, 0, 255, 0.1);
            overflow: hidden; backdrop-filter: blur(15px) saturate(180%);
            margin-bottom: 20px;
        }

        #game-canvas { width: 100%; height: 100%; }

        .boss-ui {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 90%; height: 35px; background: rgba(0, 0, 0, 0.8);
            border: 3px solid #ff5555; border-radius: 20px; overflow: hidden;
            z-index: 10; display: none; backdrop-filter: blur(5px);
        }

        .boss-bar { height: 100%; background: linear-gradient(to right, #ff0000, #ff5555, #ff8888); width: 100%; transition: width 0.5s; }
        .boss-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-weight: bold; text-shadow: 2px 2px 4px black;
            font-size: 1.2rem;
        }

        .dev-panel {
            position: absolute; top: 20px; left: 20px; width: 350px;
            background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(20px) saturate(180%);
            border: 2px solid var(--accent); border-radius: 15px;
            box-shadow: 0 0 30px rgba(255, 255, 0, 0.5);
            padding: 20px; z-index: 100; display: none;
            overflow-y: auto; max-height: 80%;
        }

        .dev-panel h3 { color: var(--accent); margin-bottom: 15px; text-align: center; }
        .dev-category { margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 15px; }
        .dev-category h4 { color: var(--secondary); margin-bottom: 10px; }
        .dev-category label { display: block; margin: 8px 0; color: #aaa; }
        .dev-category input[type="range"] { width: 100%; margin: 5px 0; }
        .dev-category button {
            background: linear-gradient(45deg, #ff00ff, #aa00ff);
            color: white; border: none; padding: 8px 15px;
            border-radius: 5px; margin: 5px; cursor: pointer;
            transition: all 0.3s;
        }
        .dev-category button:hover { background: linear-gradient(45deg, #ff33ff, #cc33ff); transform: scale(1.05); }

        .controls {
            width: 1100px; display: flex; gap: 15px; margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn-main, .btn-dev {
            flex: 1; padding: 16px 32px; font-size: 1.2rem;
            border: none; border-radius: 50px; cursor: pointer;
            font-weight: bold; transition: all 0.3s;
            min-width: 160px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .btn-main {
            background: linear-gradient(45deg, var(--primary), #aa00ff);
            color: #fff; border: 3px solid rgba(255, 255, 255, 0.3);
        }

        .btn-dev {
            background: linear-gradient(45deg, var(--accent), #ffaa00);
            color: #000; border: 3px solid rgba(255, 255, 255, 0.5);
        }

        .btn-main:hover, .btn-dev:hover {
            transform: translateY(-4px); box-shadow: 0 10px 25px rgba(0,0,0,0.6);
        }

        .instructions {
            width: 1100px; background: rgba(0, 0, 0, 0.8);
            border-radius: 15px; padding: 20px; margin-top: 10px;
            border: 3px solid var(--primary); backdrop-filter: blur(10px);
            display: none;
        }

        .instructions h2 { color: var(--primary); margin-bottom: 15px; text-align: center; }

        body::after {
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background:
                radial-gradient(circle at 20% 50%, rgba(120, 0, 200, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 150, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(255, 50, 50, 0.05) 0%, transparent 50%);
            pointer-events: none; z-index: -1;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">KCM-æŒ–åœŸè±† 3.0 </h1>
        <p style="color:#666;">ä½¿ç”¨è‡ªå®šä¹‰å›¾ç‰‡èµ„æº | å®Œå…¨å¼€å‘è€…æ¨¡å¼ | å½“å‰æ³¢æ¬¡: <span id="wave-val" style="color:var(--secondary)">1</span></p>
    </div>

    <div class="hud">
        <div class="hud-item"><div class="hud-label">å¾—åˆ†</div><div id="score" class="hud-value">0</div></div>
        <div class="hud-item"><div class="hud-label">ç”Ÿå‘½å€¼</div><div id="health" class="hud-value">200</div></div>
        <div class="hud-item"><div class="hud-label">ç­‰çº§</div><div id="level" class="hud-value">1</div></div>
        <div class="hud-item"><div class="hud-label">è¿å‡»</div><div id="combo" class="hud-value">0</div></div>
        <div class="hud-item"><div class="hud-label">æ”»å‡»åŠ›</div><div id="damage" class="hud-value">50</div></div>
        
        <div class="ability-bar">
            <div class="ability" data-key="Q" data-skill="lightning">
                <div class="ability-icon">âš¡</div>
                <div class="ability-key">Q</div>
                <div class="auto-toggle active" id="auto-toggle-1"></div>
                <div class="ability-cooldown" id="cooldown1"></div>
            </div>
            <div class="ability" data-key="W" data-skill="shield">
                <div class="ability-icon">ğŸ›¡ï¸</div>
                <div class="ability-key">W</div>
                <div class="auto-toggle active" id="auto-toggle-2"></div>
                <div class="ability-cooldown" id="cooldown2"></div>
            </div>
            <div class="ability" data-key="E" data-skill="blackhole">
                <div class="ability-icon">ğŸŒ€</div>
                <div class="ability-key">E</div>
                <div class="auto-toggle active" id="auto-toggle-3"></div>
                <div class="ability-cooldown" id="cooldown3"></div>
            </div>
            <div class="ability" data-key="R" data-skill="drone">
                <div class="ability-icon">ğŸŒŸ</div>
                <div class="ability-key">R</div>
                <div class="auto-toggle active" id="auto-toggle-4"></div>
                <div class="ability-cooldown" id="cooldown4"></div>
            </div>
            <div class="ability" data-key="T" data-skill="timestop">
                <div class="ability-icon">â³</div>
                <div class="ability-key">T</div>
                <div class="auto-toggle active" id="auto-toggle-5"></div>
                <div class="ability-cooldown" id="cooldown5"></div>
            </div>
        </div>
    </div>

    <div class="game-container">
        <div class="boss-ui" id="boss-ui">
            <div class="boss-bar" id="boss-bar"></div>
            <div class="boss-text" id="boss-text">BOSS: 100%</div>
        </div>
        
        <div class="dev-panel" id="dev-panel">
            <h3>ğŸ§ª å®Œå…¨å¼€å‘è€…æ¨¡å¼</h3>
            
            <div class="dev-category">
                <h4>ç©å®¶å±æ€§</h4>
                <label>ç”Ÿå‘½å€¼: <span id="dev-health-val">200</span>
                    <input type="range" id="dev-health" min="1" max="10000" value="200" step="10">
                </label>
                <label>æ”»å‡»åŠ›: <span id="dev-damage-val">50</span>
                    <input type="range" id="dev-damage" min="1" max="1000" value="50" step="5">
                </label>
                <label>ç§»åŠ¨é€Ÿåº¦: <span id="dev-speed-val">8</span>
                    <input type="range" id="dev-speed" min="1" max="20" value="8" step="0.5">
                </label>
                <label>å°„é€Ÿ(ms): <span id="dev-firerate-val">100</span>
                    <input type="range" id="dev-firerate" min="10" max="1000" value="100" step="10">
                </label>
            </div>
            
            <div class="dev-category">
                <h4>è°ƒè¯•å·¥å…·</h4>
                <button id="dev-invincible">æ— æ•Œæ¨¡å¼: å…³</button>
                <button id="dev-onehit">ä¸€å‡»å¿…æ€: å…³</button>
                <button id="dev-spawn-boss">å¬å”¤BOSS</button>
                <button id="dev-spawn-enemy">ç”Ÿæˆæ•Œäºº</button>
                <button id="dev-skip-wave">è·³è¿‡æ³¢æ¬¡</button>
            </div>
            
            <div class="dev-category">
                <h4>é¢„è®¾é…ç½®</h4>
                <select id="dev-presets">
                    <option value="normal">æ­£å¸¸æ¨¡å¼</option>
                    <option value="easy">ç®€å•æ¨¡å¼</option>
                    <option value="hard">å›°éš¾æ¨¡å¼</option>
                    <option value="sandbox">æ²™ç›’æ¨¡å¼</option>
                </select>
                <button id="dev-save">ä¿å­˜é…ç½®</button>
                <button id="dev-load">åŠ è½½é…ç½®</button>
                <button id="dev-export">å¯¼å‡ºé…ç½®</button>
            </div>
            
            <div class="dev-category">
                <h4>æ¸¸æˆæ§åˆ¶</h4>
                <label>æ•Œäººç”Ÿæˆé€Ÿç‡: <span id="dev-spawnrate-val">1.0</span>x
                    <input type="range" id="dev-spawnrate" min="0.1" max="5.0" value="1.0" step="0.1">
                </label>
                <label>æ•Œäººç”Ÿå‘½å€æ•°: <span id="dev-enemyhp-val">1.0</span>x
                    <input type="range" id="dev-enemyhp" min="0.1" max="10.0" value="1.0" step="0.1">
                </label>
                <button id="dev-clear-enemies">æ¸…é™¤æ‰€æœ‰æ•Œäºº</button>
                <button id="dev-clear-bullets">æ¸…é™¤æ‰€æœ‰å­å¼¹</button>
            </div>
        </div>
        
        <canvas id="game-canvas" width="1100" height="650"></canvas>
    </div>

    <div class="controls">
        <button class="btn-main" id="start-btn">å¼€å§‹æ¸¸æˆ</button>
        <button class="btn-main" id="pause-btn">æš‚åœæ¸¸æˆ</button>
        <button class="btn-main" id="reset-btn">é‡ç½®æ¸¸æˆ</button>
        <button class="btn-dev" id="devmode-btn">å¼€å‘è€…æ¨¡å¼</button>
        <button class="btn-main" id="instructions-btn">æ¸¸æˆè¯´æ˜</button>
    </div>

    <div class="instructions" id="instructions-panel">
        <h2>ğŸ® ç‰¹è‰²è¯´æ˜</h2>
        <p>æœ¬ç‰ˆæœ¬ä½¿ç”¨äº†æ¥è‡ªã€é“¾æ¥å†…å®¹ã€‘çš„è‡ªå®šä¹‰å›¾ç‰‡èµ„æºï¼š</p>
        <ul>
            <li><strong>æ™®é€šæ•Œäºº</strong>: 68c4300e86454f137181048533f853ce.png (260Ã—210)</li>
            <li><strong>å¿«é€Ÿæ•Œäºº</strong>: 0d57820732fbd6b484c274d9ec98df2b.png (154Ã—155)</li>
            <li><strong>å¦å…‹æ•Œäºº</strong>: 3fac8eb5212ea04b3e7b48a079e43d48.png (125Ã—126)</li>
            <li><strong>å½©è™¹æ•Œäºº(gay0)</strong>: a2010e7766c32a84a60fe90b8e1332aa.png (640Ã—480)</li>
            <li><strong>é‡èŠ±BOSS</strong>: ä½¿ç”¨å½©è™¹æ•Œäººå›¾ç‰‡</li>
        </ul>
        <p>æŒ‰ <kbd>~</kbd> é”®å¼€å¯å¼€å‘è€…æ¨¡å¼ï¼Œå¯ä»¥å®æ—¶è°ƒæ•´æ‰€æœ‰æ¸¸æˆå‚æ•°ï¼</p>
    </div>

    <script>
        // ==================== æ¸¸æˆå¼•æ“æ ¸å¿ƒ ====================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // ==================== è‡ªå®šä¹‰å›¾ç‰‡èµ„æºåŠ è½½ ====================
        // åŸºäºã€é“¾æ¥å†…å®¹ã€‘çš„å›¾ç‰‡é“¾æ¥
        const enemyImages = {
            normal: new Image(),
            fast: new Image(),
            tank: new Image(),
            gay0: new Image(),
            sigma: new Image(),
            gqh: new Image(),
            bossNormal: new Image(),
            shadowT: new Image(),
            wildflower: new Image()
        };
        
        // åˆ†é…å›¾ç‰‡é“¾æ¥
        enemyImages.normal.src = "https://i.ibb.co/fYsJk2DB/68c4300e86454f137181048533f853ce.png";
        enemyImages.fast.src = "https://i.ibb.co/nMfzgZ6D/0d57820732fbd6b484c274d9ec98df2b.png";
        enemyImages.tank.src = "https://i.ibb.co/Mx2sxgBM/3fac8eb5212ea04b3e7b48a079e43d48.png";
        enemyImages.gay0.src = "https://i.ibb.co/yFHS0R72/a2010e7766c32a84a60fe90b8e1332aa.png";
        
        // ä¸ºå…¶ä»–æ•Œäººç±»å‹è®¾ç½®é»˜è®¤å›¾ç‰‡
        enemyImages.sigma.src = enemyImages.normal.src;
        enemyImages.gqh.src = enemyImages.tank.src;
        
        // BOSSå›¾ç‰‡è®¾ç½®
        enemyImages.bossNormal.src = "https://pub-141831e61e69445289222976a15b6fb3.r2.dev/Image_to_url_V2/474492734b053576d92067d8a8939b4e-imagetourl.cloud-1770938930310-8c4ahh.png";
        enemyImages.shadowT.src = "https://cdn.luogu.com.cn/upload/image_hosting/gcrsj6dz.png";
        enemyImages.wildflower.src = enemyImages.gay0.src; // ä½¿ç”¨å½©è™¹æ•Œäººå›¾ç‰‡ä½œä¸ºé‡èŠ±BOSS
        
        // å›¾ç‰‡åŠ è½½çŠ¶æ€è·Ÿè¸ª
        let imagesLoaded = 0;
        const totalImages = Object.keys(enemyImages).length;
        
        for (let key in enemyImages) {
            enemyImages[key].onload = () => {
                imagesLoaded++;
                console.log(`${key} å›¾ç‰‡åŠ è½½å®Œæˆ (${imagesLoaded}/${totalImages})`);
            };
            enemyImages[key].onerror = () => {
                console.error(`${key} å›¾ç‰‡åŠ è½½å¤±è´¥`);
            };
        }
        
        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameRunning = false;
        let gamePaused = false;
        let gameLoop;
        let score = 0;
        let health = 200;
        let maxHealth = 200;
        let playerLevel = 1;
        let xp = 0;
        let xpToNextLevel = 100;
        let wave = 1;
        let combo = 0;
        let maxCombo = 0;
        let comboTimeout = null;
        let godMode = false;
        let devMode = false;
        let bossSpawnCount = 0;
        let lastFrameTime = Date.now();
        let lastLevelUpTime = 0;
        
        // ==================== ç©å®¶å±æ€§ ====================
        const player = {
            x: canvas.width / 2 - 25,
            y: canvas.height / 2 - 25,
            width: 50,
            height: 50,
            speed: 8,
            color: '#00a8ff',
            bullets: [],
            lastShot: 0,
            shotDelay: 100,
            damage: 50,
            pierce: 0,
            explosive: false,
            tripleShot: true,
            homing: false,
            bulletCount: 1,
            regenRate: 0,
            dodgeChance: 0,
            invincible: false,
            oneHitKill: false
        };
        
        // ==================== æŠ€èƒ½ç³»ç»Ÿ ====================
        const abilities = {
            lightning: { name: "ç”µç£ç‚®", cooldown: 8000, lastUsed: 0, auto: true },
            shield: { name: "ç»å¯¹é˜²å¾¡", cooldown: 12000, lastUsed: 0, auto: true, active: false, duration: 0 },
            blackhole: { name: "é»‘æ´", cooldown: 15000, lastUsed: 0, auto: true },
            drone: { name: "æµ®æ¸¸ç‚®", cooldown: 20000, lastUsed: 0, auto: true, drones: [] },
            timestop: { name: "æ—¶é—´åœæ»", cooldown: 25000, lastUsed: 0, auto: true, active: false, duration: 0 }
        };
        
        // ==================== æ•Œäººç³»ç»Ÿ ====================
        let enemies = [];
        let particles = [];
        let enemyBullets = [];
        let boss = null;
        let bossActive = false;
        
        // ==================== ç²’å­ç³»ç»Ÿ ====================
        class Particle {
            constructor(x, y, options = {}) {
                this.x = x;
                this.y = y;
                this.vx = options.vx || (Math.random() - 0.5) * 8;
                this.vy = options.vy || (Math.random() - 0.5) * 8;
                this.life = 1.0;
                this.maxLife = options.life || 1.0;
                this.lifeDecay = options.lifeDecay || 0.02;
                this.size = options.size || Math.random() * 4 + 2;
                this.color = options.color || '#ffffff';
                this.type = options.type || 'circle';
            }
            
            update() {
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.lifeDecay;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                
                switch(this.type) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'square':
                        ctx.fillRect(this.x, this.y, this.size, this.size);
                        break;
                    case 'star':
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2) / 5;
                            const radius = this.size;
                            ctx.lineTo(this.x + Math.cos(angle) * radius, this.y + Math.sin(angle) * radius);
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        }
        
        // ==================== å®Œå…¨å¼€å‘è€…æ¨¡å¼ç®¡ç†å™¨ ====================
        class DevModeManager {
            constructor() {
                this.active = false;
                this.presets = {
                    normal: { health: 200, damage: 50, speed: 8, shotDelay: 100 },
                    easy: { health: 500, damage: 100, speed: 10, shotDelay: 80 },
                    hard: { health: 100, damage: 30, speed: 6, shotDelay: 150 },
                    sandbox: { health: 9999, damage: 999, speed: 15, shotDelay: 50 }
                };
                this.config = {};
                this.init();
            }
            
            init() {
                this.bindSliders();
                this.bindButtons();
                this.loadConfig();
            }
            
            toggle() {
                this.active = !this.active;
                document.getElementById('dev-panel').style.display = this.active ? 'block' : 'none';
                if (this.active) this.updateAllDisplays();
            }
            
            bindSliders() {
                // ç©å®¶å±æ€§æ»‘å—
                document.getElementById('dev-health').oninput = (e) => {
                    player.health = parseInt(e.target.value);
                    maxHealth = player.health;
                    document.getElementById('dev-health-val').textContent = player.health;
                    document.getElementById('health').textContent = Math.round(player.health);
                };
                
                document.getElementById('dev-damage').oninput = (e) => {
                    player.damage = parseInt(e.target.value);
                    document.getElementById('dev-damage-val').textContent = player.damage;
                    document.getElementById('damage').textContent = player.damage;
                };
                
                document.getElementById('dev-speed').oninput = (e) => {
                    player.speed = parseFloat(e.target.value);
                    document.getElementById('dev-speed-val').textContent = player.speed;
                };
                
                document.getElementById('dev-firerate').oninput = (e) => {
                    player.shotDelay = parseInt(e.target.value);
                    document.getElementById('dev-firerate-val').textContent = player.shotDelay;
                };
                
                // æ¸¸æˆæ§åˆ¶æ»‘å—
                document.getElementById('dev-spawnrate').oninput = (e) => {
                    this.config.spawnRate = parseFloat(e.target.value);
                    document.getElementById('dev-spawnrate-val').textContent = this.config.spawnRate;
                };
                
                document.getElementById('dev-enemyhp').oninput = (e) => {
                    this.config.enemyHpMultiplier = parseFloat(e.target.value);
                    document.getElementById('dev-enemyhp-val').textContent = this.config.enemyHpMultiplier;
                };
            }
            
            bindButtons() {
                document.getElementById('dev-invincible').onclick = () => {
                    player.invincible = !player.invincible;
                    document.getElementById('dev-invincible').textContent = `æ— æ•Œæ¨¡å¼: ${player.invincible ? 'å¼€' : 'å…³'}`;
                };
                
                document.getElementById('dev-onehit').onclick = () => {
                    player.oneHitKill = !player.oneHitKill;
                    document.getElementById('dev-onehit').textContent = `ä¸€å‡»å¿…æ€: ${player.oneHitKill ? 'å¼€' : 'å…³'}`;
                };
                
                document.getElementById('dev-spawn-boss').onclick = () => spawnBoss();
                document.getElementById('dev-spawn-enemy').onclick = () => spawnRandomEnemy();
                document.getElementById('dev-skip-wave').onclick = () => { wave++; spawnWave(); };
                document.getElementById('dev-clear-enemies').onclick = () => { enemies = []; };
                document.getElementById('dev-clear-bullets').onclick = () => { enemyBullets = []; };
                
                // é¢„è®¾é…ç½®
                document.getElementById('dev-presets').onchange = (e) => {
                    this.applyPreset(e.target.value);
                };
                
                document.getElementById('dev-save').onclick = () => this.saveConfig();
                document.getElementById('dev-load').onclick = () => this.loadConfig();
                document.getElementById('dev-export').onclick = () => this.exportConfig();
            }
            
            applyPreset(name) {
                const preset = this.presets[name];
                player.health = preset.health;
                maxHealth = preset.health;
                player.damage = preset.damage;
                player.speed = preset.speed;
                player.shotDelay = preset.shotDelay;
                
                this.updateAllDisplays();
                updateUI();
            }
            
            updateAllDisplays() {
                document.getElementById('dev-health-val').textContent = player.health;
                document.getElementById('dev-damage-val').textContent = player.damage;
                document.getElementById('dev-speed-val').textContent = player.speed;
                document.getElementById('dev-firerate-val').textContent = player.shotDelay;
                
                document.getElementById('dev-health').value = player.health;
                document.getElementById('dev-damage').value = player.damage;
                document.getElementById('dev-speed').value = player.speed;
                document.getElementById('dev-firerate').value = player.shotDelay;
            }
            
            saveConfig() {
                this.config = {
                    player: {
                        health: player.health,
                        damage: player.damage,
                        speed: player.speed,
                        shotDelay: player.shotDelay
                    },
                    game: {
                        spawnRate: this.config.spawnRate || 1.0,
                        enemyHpMultiplier: this.config.enemyHpMultiplier || 1.0
                    },
                    timestamp: Date.now()
                };
                localStorage.setItem('kcm3-dev-config', JSON.stringify(this.config));
                alert('é…ç½®å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨ï¼');
            }
            
            loadConfig() {
                const saved = localStorage.getItem('kcm3-dev-config');
                if (saved) {
                    this.config = JSON.parse(saved);
                    Object.assign(player, this.config.player);
                    this.updateAllDisplays();
                    updateUI();
                    alert('é…ç½®å·²åŠ è½½ï¼');
                } else {
                    alert('æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„é…ç½®ï¼');
                }
            }
            
            exportConfig() {
                const configStr = JSON.stringify(this.config, null, 2);
                const blob = new Blob([configStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `kcm3-config-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }
        
        const devManager = new DevModeManager();
        
        // ==================== æ¸¸æˆæ§åˆ¶å‡½æ•° ====================
        function initGame() {
            score = 0;
            health = maxHealth;
            playerLevel = 1;
            xp = 0;
            xpToNextLevel = 100;
            wave = 1;
            bossSpawnCount = 0;
            
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height / 2 - 25;
            player.bullets = [];
            player.lastShot = 0;
            player.invincible = false;
            player.oneHitKill = false;
            
            enemies = [];
            particles = [];
            enemyBullets = [];
            boss = null;
            bossActive = false;
            
            for (let ability in abilities) {
                abilities[ability].lastUsed = 0;
                abilities[ability].active = false;
                abilities[ability].auto = true;
            }
            
            updateUI();
            document.getElementById('boss-ui').style.display = 'none';
            document.getElementById('wave-val').textContent = wave;
        }
        
        function startGame() {
            if (gameRunning) return;
            initGame();
            gameRunning = true;
            gamePaused = false;
            gameLoop = requestAnimationFrame(updateGame);
            document.getElementById('start-btn').textContent = 'æ¸¸æˆä¸­...';
            spawnWave();
        }
        
        function pauseGame() {
            if (!gameRunning) return;
            gamePaused = !gamePaused;
            if (gamePaused) {
                cancelAnimationFrame(gameLoop);
                document.getElementById('pause-btn').textContent = 'ç»§ç»­æ¸¸æˆ';
            } else {
                gameLoop = requestAnimationFrame(updateGame);
                document.getElementById('pause-btn').textContent = 'æš‚åœæ¸¸æˆ';
            }
        }
        
        function resetGame() {
            gameRunning = false;
            cancelAnimationFrame(gameLoop);
            initGame();
            ctx.fillStyle = '#050010';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ç‚¹å‡»å¼€å§‹æ¸¸æˆè¿›å…¥ KCM-æŒ–åœŸè±† 3.0 ', canvas.width/2, canvas.height/2);
            document.getElementById('start-btn').textContent = 'å¼€å§‹æ¸¸æˆ';
        }
        
        // ==================== æ¸¸æˆæ›´æ–°å¾ªç¯ ====================
        function updateGame() {
            if (!gameRunning || gamePaused) return;
            
            const currentTime = Date.now();
            
            // æ¸…é™¤ç”»å¸ƒ
            ctx.fillStyle = '#050010';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç§»åŠ¨ç©å®¶
            movePlayer();
            
            // å°„å‡»
            if (mouse.pressed) shootPlayer();
            
            // æ›´æ–°å­å¼¹
            updateBullets();
            
            // æ›´æ–°æ•Œäºº
            updateEnemies();
            
            // æ›´æ–°ç²’å­
            updateParticles();
            
            // ç»˜åˆ¶ç©å®¶
            drawPlayer();
            
            // ç»˜åˆ¶UI
            drawUI();
            
            // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
            if (health <= 0) {
                endGame();
                return;
            }
            
            lastFrameTime = currentTime;
            gameLoop = requestAnimationFrame(updateGame);
        }
        
        // ==================== æ¸¸æˆé€»è¾‘å‡½æ•° ====================
        function movePlayer() {
            let moveX = 0, moveY = 0;
            if (keys['w'] || keys['ArrowUp']) moveY -= player.speed;
            if (keys['s'] || keys['ArrowDown']) moveY += player.speed;
            if (keys['a'] || keys['ArrowLeft']) moveX -= player.speed;
            if (keys['d'] || keys['ArrowRight']) moveX += player.speed;
            
            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.7071;
                moveY *= 0.7071;
            }
            
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x + moveX));
            player.y = Math.max(0, Math.min(canvas.height - player.height, player.y + moveY));
        }
        
        function shootPlayer() {
            const now = Date.now();
            if (now - player.lastShot < player.shotDelay) return;
            
            player.lastShot = now;
            const dx = mouse.x - (player.x + player.width/2);
            const dy = mouse.y - (player.y + player.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance === 0) return;
            
            for (let i = 0; i < player.bulletCount; i++) {
                let angleOffset = 0;
                if (player.tripleShot && i < 3) angleOffset = (i - 1) * 0.1;
                
                const angle = Math.atan2(dy, dx) + angleOffset;
                const bullet = {
                    x: player.x + player.width/2,
                    y: player.y + player.height/2,
                    vx: Math.cos(angle) * 16,
                    vy: Math.sin(angle) * 16,
                    damage: player.damage,
                    life: 100
                };
                player.bullets.push(bullet);
            }
            
            // æªå£ç«ç„°ç²’å­
            for (let i = 0; i < 8; i++) {
                particles.push(new Particle(
                    player.x + player.width/2,
                    player.y + player.height/2,
                    {
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        color: '#ffff00',
                        type: 'star',
                        lifeDecay: 0.05
                    }
                ));
            }
        }
        
        function updateBullets() {
            // ç©å®¶å­å¼¹
            for (let i = player.bullets.length - 1; i >= 0; i--) {
                const bullet = player.bullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life--;
                
                // ç»˜åˆ¶å­å¼¹
                ctx.save();
                ctx.fillStyle = '#00ffaa';
                ctx.shadowColor = '#00ffaa';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // è¾¹ç•Œæ£€æŸ¥
                if (bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height || 
                    bullet.life <= 0) {
                    player.bullets.splice(i, 1);
                    continue;
                }
                
                // ç¢°æ’æ£€æµ‹ - æ•Œäºº
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (bullet.x > enemy.x && bullet.x < enemy.x + enemy.width &&
                        bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {
                        
                        const damage = player.oneHitKill ? enemy.health : bullet.damage;
                        enemy.health -= damage;
                        
                        // å‡»ä¸­ç‰¹æ•ˆ
                        for (let k = 0; k < 5; k++) {
                            particles.push(new Particle(
                                bullet.x, bullet.y,
                                {
                                    vx: (Math.random() - 0.5) * 5,
                                    vy: (Math.random() - 0.5) * 5,
                                    color: enemy.color,
                                    lifeDecay: 0.03
                                }
                            ));
                        }
                        
                        if (enemy.health <= 0) {
                            score += 100;
                            xp += 20;
                            combo++;
                            if (combo > maxCombo) maxCombo = combo;
                            resetComboTimer();
                            
                            // æ•Œäººæ­»äº¡ç‰¹æ•ˆ
                            createEnemyDeathParticles(enemy);
                            enemies.splice(j, 1);
                        }
                        
                        if (!player.pierce) {
                            player.bullets.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // ç¢°æ’æ£€æµ‹ - Boss
                if (boss && bossActive) {
                    if (bullet.x > boss.x && bullet.x < boss.x + boss.width &&
                        bullet.y > boss.y && bullet.y < boss.y + boss.height) {
                        
                        const damage = player.oneHitKill ? boss.health : bullet.damage;
                        boss.health -= damage;
                        updateBossHealth();
                        
                        if (boss.health <= 0) {
                            bossActive = false;
                            score += 5000;
                            xp += 500;
                            document.getElementById('boss-ui').style.display = 'none';
                            
                            // Bossæ­»äº¡ç‰¹æ•ˆ
                            for (let k = 0; k < 50; k++) {
                                particles.push(new Particle(
                                    boss.x + boss.width/2,
                                    boss.y + boss.height/2,
                                    {
                                        vx: (Math.random() - 0.5) * 15,
                                        vy: (Math.random() - 0.5) * 15,
                                        color: boss.type === 'wildflower' ? '#ff69b4' : '#ff00ff',
                                        size: Math.random() * 10 + 5,
                                        lifeDecay: 0.02
                                    }
                                ));
                            }
                        }
                        
                        if (!player.pierce) {
                            player.bullets.splice(i, 1);
                        }
                    }
                }
            }
            
            // æ•Œäººå­å¼¹
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                // ç»˜åˆ¶å­å¼¹
                ctx.save();
                ctx.fillStyle = bullet.color || '#ff5555';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius || 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // è¾¹ç•Œæ£€æŸ¥
                if (bullet.x < -50 || bullet.x > canvas.width + 50 ||
                    bullet.y < -50 || bullet.y > canvas.height + 50) {
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                // ç©å®¶ç¢°æ’
                if (!player.invincible && !abilities.shield.active &&
                    bullet.x > player.x && bullet.x < player.x + player.width &&
                    bullet.y > player.y && bullet.y < player.y + player.height) {
                    
                    health -= bullet.damage || 10;
                    updateUI();
                    enemyBullets.splice(i, 1);
                    
                    if (health <= 0) {
                        health = 0;
                        endGame();
                    }
                }
            }
        }
        
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // ç§»åŠ¨æ•Œäºº
                const dx = (player.x + player.width/2) - (enemy.x + enemy.width/2);
                const dy = (player.y + player.height/2) - (enemy.y + enemy.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
                
                // ç»˜åˆ¶æ•Œäºº - ä½¿ç”¨å›¾ç‰‡
                ctx.save();
                
                let enemyImg = enemyImages.normal;
                let shadowColor = enemy.color;
                let shadowBlur = 15;
                
                switch(enemy.type) {
                    case 'normal':
                        enemyImg = enemyImages.normal;
                        shadowColor = '#ff5555';
                        break;
                    case 'fast':
                        enemyImg = enemyImages.fast;
                        shadowColor = '#ffaa00';
                        break;
                    case 'tank':
                        enemyImg = enemyImages.tank;
                        shadowColor = '#5555ff';
                        break;
                    case 'gay0':
                        enemyImg = enemyImages.gay0;
                        shadowColor = 'rgba(255, 0, 255, 0.7)';
                        shadowBlur = 20;
                        break;
                    case 'sigma':
                        enemyImg = enemyImages.sigma;
                        shadowColor = 'rgba(0, 0, 0, 0.8)';
                        break;
                    case 'gqh':
                        enemyImg = enemyImages.gqh;
                        shadowColor = '#ff69b4';
                        break;
                }
                
                // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦åŠ è½½å®Œæˆ
                if (enemyImg.complete && enemyImg.width > 0) {
                    // æ·»åŠ å‘å…‰æ•ˆæœ
                    ctx.shadowColor = shadowColor;
                    ctx.shadowBlur = shadowBlur;
                    
                    // ç»˜åˆ¶æ•Œäººå›¾ç‰‡
                    ctx.drawImage(enemyImg, enemy.x, enemy.y, enemy.width, enemy.height);
                    
                    // å¦‚æœæ˜¯å½©è™¹æ•Œäººï¼Œæ·»åŠ é—ªçƒæ•ˆæœ
                    if (enemy.type === 'gay0') {
                        const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;
                        ctx.globalAlpha = pulse;
                        ctx.drawImage(enemyImg, enemy.x, enemy.y, enemy.width, enemy.height);
                        ctx.globalAlpha = 1.0;
                    }
                } else {
                    // å›¾ç‰‡æœªåŠ è½½ï¼Œä½¿ç”¨åŸå§‹é¢œè‰²æ–¹å—
                    ctx.fillStyle = enemy.color;
                    ctx.shadowColor = enemy.color;
                    ctx.shadowBlur = 15;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 0;
                    ctx.fillText(enemy.type, enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                }
                
                // ç»˜åˆ¶è¡€æ¡
                if (enemy.health < enemy.maxHealth) {
                    const healthPercent = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = '#220000';
                    ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
                    ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : (healthPercent > 0.25 ? '#ffff00' : '#ff0000');
                    ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * healthPercent, 5);
                }
                ctx.restore();
                
                // ç©å®¶ç¢°æ’æ£€æµ‹
                if (!player.invincible && !abilities.shield.active &&
                    enemy.x < player.x + player.width &&
                    enemy.x + enemy.width > player.x &&
                    enemy.y < player.y + player.height &&
                    enemy.y + enemy.height > player.y) {
                    
                    health -= 15;
                    updateUI();
                    enemies.splice(i, 1);
                    
                    if (health <= 0) {
                        health = 0;
                        endGame();
                    }
                }
            }
            
            // æ›´æ–°Boss
            if (boss && bossActive) {
                boss.x += boss.speed * boss.moveDirection;
                if (boss.x <= 50 || boss.x + boss.width >= canvas.width - 50) {
                    boss.moveDirection *= -1;
                }
                
                // ç»˜åˆ¶Boss
                ctx.save();
                let bossImg;
                let shadowColor = '#ff00ff';
                let shadowBlur = 30;
                
                if (boss.type === 'wildflower') {
                    bossImg = enemyImages.wildflower;
                    shadowColor = 'rgba(255, 105, 180, 0.8)';
                    shadowBlur = 40;
                } else if (boss.type === 'shadowT') {
                    bossImg = enemyImages.shadowT;
                    shadowColor = 'rgba(0, 0, 0, 0.9)';
                } else {
                    bossImg = enemyImages.bossNormal;
                }
                
                // æ£€æŸ¥BOSSå›¾ç‰‡æ˜¯å¦åŠ è½½å®Œæˆ
                if (bossImg.complete && bossImg.width > 0) {
                    ctx.shadowColor = shadowColor;
                    ctx.shadowBlur = shadowBlur;
                    ctx.drawImage(bossImg, boss.x, boss.y, boss.width, boss.height);
                    
                    // BOSSç‰¹æ®Šæ•ˆæœ
                    if (boss.type === 'wildflower') {
                        const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
                        ctx.globalAlpha = pulse;
                        ctx.drawImage(bossImg, boss.x, boss.y, boss.width, boss.height);
                        ctx.globalAlpha = 1.0;
                    }
                } else {
                    // å›¾ç‰‡æœªåŠ è½½æ—¶çš„åå¤‡æ–¹æ¡ˆ
                    if (boss.type === 'wildflower') {
                        ctx.fillStyle = 'rgba(255, 105, 180, 0.9)';
                        ctx.shadowColor = '#ff69b4';
                        ctx.shadowBlur = 40;
                        ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                        ctx.fillStyle = '#ffb6c1';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = 10;
                        ctx.fillText('ğŸŒ¸', boss.x + boss.width/2, boss.y + boss.height/2);
                    } else {
                        ctx.fillStyle = boss.color || '#ff00ff';
                        ctx.shadowColor = boss.color || '#ff00ff';
                        ctx.shadowBlur = 30;
                        ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                    }
                }
                ctx.restore();
                
                // BOSSå°„å‡»
                const now = Date.now();
                if (now - boss.lastShot > boss.shotDelay) {
                    shootBoss();
                    boss.lastShot = now;
                }
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.update();
                particle.draw();
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // ==================== ç»˜åˆ¶å‡½æ•° ====================
        function drawPlayer() {
            ctx.save();
            ctx.fillStyle = player.color;
            ctx.shadowColor = player.color;
            ctx.shadowBlur = 20;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            // ç»˜åˆ¶ç©å®¶æ ‡è¯†
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 0;
            ctx.fillText('P', player.x + player.width/2, player.y + player.height/2);
            
            // æŠ¤ç›¾æ•ˆæœ
            if (abilities.shield.active) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 5;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2 + 15, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // æ— æ•Œæ¨¡å¼æŒ‡ç¤º
            if (player.invincible) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2 + 25, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        function drawUI() {
            // åœ¨ç”»é¢å³ä¸Šè§’æ˜¾ç¤ºå¼€å‘è€…æ¨¡å¼çŠ¶æ€
            if (devManager.active) {
                ctx.save();
                
                // ç»˜åˆ¶å¼€å‘è€…æ¨¡å¼çŠ¶æ€é¢æ¿èƒŒæ™¯ï¼ˆæ¯›ç»ç’ƒæ•ˆæœï¼‰
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(canvas.width - 210, 10, 200, 120);
                
                // æ·»åŠ è¾¹æ¡†æ•ˆæœ
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width - 210, 10, 200, 120);
                
                // é¢æ¿æ ‡é¢˜
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('ğŸ§ª å¼€å‘è€…æ¨¡å¼', canvas.width - 200, 30);
                
                // çŠ¶æ€ä¿¡æ¯
                ctx.fillStyle = '#00ffff';
                ctx.font = '14px Arial';
                let yPos = 55;
                
                ctx.fillText(`æ— æ•Œ: ${player.invincible ? 'âœ… å¼€å¯' : 'âŒ å…³é—­'}`, canvas.width - 200, yPos);
                yPos += 20;
                
                ctx.fillText(`ä¸€å‡»å¿…æ€: ${player.oneHitKill ? 'âœ… å¼€å¯' : 'âŒ å…³é—­'}`, canvas.width - 200, yPos);
                yPos += 20;
                
                ctx.fillText(`å½“å‰æ³¢æ¬¡: ${wave}`, canvas.width - 200, yPos);
                yPos += 20;
                
                ctx.fillText(`æ•Œäººæ•°é‡: ${enemies.length}`, canvas.width - 200, yPos);
                yPos += 20;
                
                // æ˜¾ç¤ºFPSï¼ˆæ€§èƒ½ç›‘æ§ï¼‰
                if (lastFrameTime) {
                    const fps = Math.round(1000 / (Date.now() - lastFrameTime));
                    ctx.fillText(`FPS: ${fps}`, canvas.width - 200, yPos);
                }
                
                // æ˜¾ç¤ºåæ ‡ä¿¡æ¯
                ctx.fillStyle = '#ffaa00';
                ctx.font = '12px Arial';
                ctx.fillText(`ç©å®¶åæ ‡: (${Math.round(player.x)}, ${Math.round(player.y)})`, canvas.width - 200, yPos + 25);
                
                ctx.restore();
            }
            
            // æ˜¾ç¤ºè¿å‡»æ•ˆæœï¼ˆå¦‚æœè¿å‡»å¤§äº10ï¼‰
            if (combo > 10) {
                ctx.save();
                ctx.fillStyle = `hsl(${Date.now() / 50 % 360}, 100%, 50%)`;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.fillText(`${combo} è¿å‡»ï¼`, canvas.width / 2, 80);
                ctx.restore();
            }
            
            // æ˜¾ç¤ºBOSSè­¦å‘Šï¼ˆå½“BOSSå³å°†å‡ºç°æ—¶ï¼‰
            if (wave % 3 === 0 && enemies.length === 0 && !bossActive) {
                ctx.save();
                const pulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('âš ï¸ BOSS å³å°†å‡ºç° âš ï¸', canvas.width / 2, canvas.height / 2 - 100);
                ctx.restore();
            }
            
            // æ˜¾ç¤ºæŠ€èƒ½å†·å´æç¤ºï¼ˆå½“æŠ€èƒ½åˆšä½¿ç”¨æ—¶ï¼‰
            const now = Date.now();
            for (const abilityKey in abilities) {
                const ability = abilities[abilityKey];
                const timeSinceUse = now - ability.lastUsed;
                if (timeSinceUse < 1000) { // æ˜¾ç¤º1ç§’å†…çš„æŠ€èƒ½ä½¿ç”¨æç¤º
                    const alpha = 1 - (timeSinceUse / 1000);
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#00ffff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`âœ¨ ${ability.name} âœ¨`, player.x + player.width/2, player.y - 40);
                    ctx.restore();
                    break; // åªæ˜¾ç¤ºä¸€ä¸ªæç¤º
                }
            }
            
            // æ˜¾ç¤ºç­‰çº§æå‡æç¤ºï¼ˆå¦‚æœæœ€è¿‘å‡çº§äº†ï¼‰
            if (lastLevelUpTime && now - lastLevelUpTime < 2000) {
                const alpha = 1 - ((now - lastLevelUpTime) / 2000);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`ğŸ‰ ç­‰çº§ ${playerLevel} ğŸ‰`, canvas.width / 2, 150);
                ctx.restore();
            }
        }
        
        // ==================== å·¥å…·å‡½æ•° ====================
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('health').textContent = Math.round(health);
            document.getElementById('level').textContent = playerLevel;
            document.getElementById('combo').textContent = combo;
            document.getElementById('damage').textContent = player.damage;
            document.getElementById('wave-val').textContent = wave;
            
            // æ›´æ–°æŠ€èƒ½å†·å´æ˜¾ç¤º
            updateAbilityCooldowns();
            
            // æ£€æŸ¥å‡çº§
            if (xp >= xpToNextLevel) {
                xp -= xpToNextLevel;
                playerLevel++;
                xpToNextLevel = Math.floor(xpToNextLevel * 1.5);
                levelUp();
            }
        }
        
        function updateAbilityCooldowns() {
            const now = Date.now();
            for (let i = 1; i <= 5; i++) {
                const abilityKeys = Object.keys(abilities);
                const ability = abilities[abilityKeys[i-1]];
                const cooldownElement = document.getElementById(`cooldown${i}`);
                if (!ability) continue;
                
                const timeSinceLastUse = now - ability.lastUsed;
                const cooldownPercent = Math.min(100, (timeSinceLastUse / ability.cooldown) * 100);
                cooldownElement.style.height = `${100 - cooldownPercent}%`;
            }
        }
        
        function updateBossHealth() {
            if (!boss) return;
            const healthPercent = (boss.health / boss.maxHealth) * 100;
            document.getElementById('boss-bar').style.width = `${healthPercent}%`;
            
            let bossName = 'BOSS';
            if (boss.type === 'wildflower') bossName = 'ğŸŒ¸ Wild flower ğŸŒ¸';
            else if (boss.type === 'shadowT') bossName = 'ğŸ‘¤ shadowT';
            else bossName = 'WTD BOSS';
            
            document.getElementById('boss-text').textContent = `${bossName}: ${Math.round(healthPercent)}%`;
        }
        
        function resetComboTimer() {
            if (comboTimeout) clearTimeout(comboTimeout);
            comboTimeout = setTimeout(() => {
                combo = 0;
                updateUI();
            }, 3000);
        }
        
        function endGame() {
            gameRunning = false;
            cancelAnimationFrame(gameLoop);
            alert(`æ¸¸æˆç»“æŸï¼\næœ€ç»ˆå¾—åˆ†: ${score}\næœ€é«˜è¿å‡»: ${maxCombo}\næ³¢æ¬¡: ${wave}`);
            resetGame();
        }
        
        function levelUp() {
            lastLevelUpTime = Date.now();
            const upgrades = [
                { name: 'æ”»å‡»åŠ›æå‡', effect: () => player.damage += 20 },
                { name: 'å°„é€Ÿæå‡', effect: () => player.shotDelay = Math.max(50, player.shotDelay - 20) },
                { name: 'ç”Ÿå‘½æå‡', effect: () => { maxHealth += 50; health += 50; } },
                { name: 'é€Ÿåº¦æå‡', effect: () => player.speed += 0.5 },
                { name: 'ç©¿é€å­å¼¹', effect: () => player.pierce += 1 },
                { name: 'ä¸‰è¿å‘', effect: () => player.tripleShot = true },
                { name: 'è¿½è¸ªå­å¼¹', effect: () => player.homing = true }
            ];
            
            const upgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
            upgrade.effect();
            
            alert(`ç­‰çº§æå‡åˆ° ${playerLevel}ï¼\nè·å¾—å¤©èµ‹ï¼š${upgrade.name}`);
            updateUI();
        }
        
        // ==================== æ•Œäººç”Ÿæˆå‡½æ•° ====================
        function spawnWave() {
            const enemyCount = Math.min(5 + wave * 2, 20);
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    if (!gameRunning) return;
                    spawnRandomEnemy();
                }, i * 500);
            }
            
            if (wave % 3 === 0) {
                setTimeout(spawnBoss, 3000);
            }
        }
        
        function spawnRandomEnemy() {
            const enemyTypes = ['normal', 'fast', 'tank', 'gay0', 'sigma', 'gqh'];
            const weights = [0.4, 0.2, 0.15, 0.1, 0.1, 0.05];
            
            let rand = Math.random();
            let type = 'normal';
            for (let i = 0; i < enemyTypes.length; i++) {
                if (rand < weights[i]) {
                    type = enemyTypes[i];
                    break;
                }
                rand -= weights[i];
            }
            
            const hpMultiplier = devManager.config.enemyHpMultiplier || 1.0;
            const enemy = {
                x: Math.random() < 0.5 ? -60 : canvas.width + 60,
                y: Math.random() * canvas.height,
                width: 0,
                height: 0,
                health: 0,
                maxHealth: 0,
                speed: 0,
                color: '#ff5555',
                type: type
            };
            
            // æ ¹æ®æ•Œäººç±»å‹è®¾ç½®ä¸åŒå±æ€§ï¼Œä½¿ç”¨å›¾ç‰‡èµ„æº
            switch(type) {
                case 'normal':
                    enemy.width = 40;
                    enemy.height = 40;
                    enemy.health = enemy.maxHealth = 500 * hpMultiplier;
                    enemy.speed = 2.5;
                    enemy.color = '#ff5555';
                    break;
                case 'fast':
                    enemy.width = 35;
                    enemy.height = 35;
                    enemy.health = enemy.maxHealth = 300 * hpMultiplier;
                    enemy.speed = 6;
                    enemy.color = '#ffaa00';
                    break;
                case 'tank':
                    enemy.width = 60;
                    enemy.height = 60;
                    enemy.health = enemy.maxHealth = 1500 * hpMultiplier;
                    enemy.speed = 1.5;
                    enemy.color = '#5555ff';
                    break;
                case 'gay0':
                    enemy.width = 50;
                    enemy.height = 50;
                    enemy.health = enemy.maxHealth = 600 * hpMultiplier;
                    enemy.speed = 4.5;
                    enemy.color = 'rgba(255, 0, 255, 0.7)';
                    break;
                case 'sigma':
                    enemy.width = 45;
                    enemy.height = 45;
                    enemy.health = enemy.maxHealth = 800 * hpMultiplier;
                    enemy.speed = 4;
                    enemy.color = 'rgba(0, 0, 0, 0.8)';
                    break;
                case 'gqh':
                    enemy.width = 65;
                    enemy.height = 65;
                    enemy.health = enemy.maxHealth = 2000 * hpMultiplier;
                    enemy.speed = 2.5;
                    enemy.color = '#ff69b4';
                    break;
            }
            
            enemies.push(enemy);
        }
        
        function spawnBoss() {
            bossActive = true;
            bossSpawnCount++;
            const isWildFlower = (bossSpawnCount % 5 === 0);
            
            if (isWildFlower) {
                boss = {
                    x: canvas.width / 2 - 100,
                    y: -150,
                    width: 200,
                    height: 200,
                    health: 60000,
                    maxHealth: 60000,
                    speed: 2.0,
                    color: '#ff69b4',
                    type: 'wildflower',
                    moveDirection: 1,
                    lastShot: 0,
                    shotDelay: 300
                };
            } else {
                const isShadowT = Math.random() < 0.5;
                boss = {
                    x: canvas.width / 2 - 100,
                    y: -150,
                    width: 200,
                    height: 200,
                    health: 3000 + wave * 600 + wave * wave,
                    maxHealth: 3000 + wave * 600 + wave * wave,
                    speed: 1.5,
                    color: isShadowT ? '#222222' : '#ff00ff',
                    type: isShadowT ? 'shadowT' : 'normal',
                    moveDirection: 1,
                    lastShot: 0,
                    shotDelay: 800
                };
            }
            
            document.getElementById('boss-ui').style.display = 'block';
            updateBossHealth();
        }
        
        function shootBoss() {
            if (!boss) return;
            
            const centerX = boss.x + boss.width/2;
            const centerY = boss.y + boss.height/2;
            
            if (boss.type === 'wildflower') {
                // é‡èŠ±å‘å°„å°–åˆº
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i / 8) + (Date.now() / 1000);
                    enemyBullets.push({
                        x: centerX, y: centerY,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        color: '#ff69b4',
                        radius: 8,
                        damage: 20
                    });
                }
            } else {
                // æ™®é€šBOSSå‘å°„å¼¹å¹•
                for (let i = 0; i < 12; i++) {
                    const angle = (Math.PI * 2 * i / 12) + Date.now() / 1000;
                    enemyBullets.push({
                        x: centerX, y: centerY,
                        vx: Math.cos(angle) * 6,
                        vy: Math.sin(angle) * 6,
                        color: boss.type === 'shadowT' ? '#666666' : '#ff00ff',
                        radius: 6,
                        damage: 15
                    });
                }
            }
        }
        
        function createEnemyDeathParticles(enemy) {
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(
                    enemy.x + enemy.width/2,
                    enemy.y + enemy.height/2,
                    {
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        color: enemy.color === 'rainbow' ? 
                            `hsl(${Math.random() * 360}, 100%, 50%)` : enemy.color,
                        size: Math.random() * 5 + 2,
                        lifeDecay: 0.03
                    }
                ));
            }
        }
        
        // ==================== äº‹ä»¶ç›‘å¬ ====================
        const keys = {};
        const mouse = { x: 0, y: 0, pressed: false };
        
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            // å¼€å‘è€…æ¨¡å¼å¿«æ·é”®
            if (key === '`' || key === '~') {
                devManager.toggle();
            }
            
            // æŠ€èƒ½å¿«æ·é”®
            if (key === 'q' || key === 'w' || key === 'e' || key === 'r' || key === 't') {
                const skillIndex = ['q','w','e','r','t'].indexOf(key);
                if (skillIndex !== -1) {
                    const abilityKeys = Object.keys(abilities);
                    const ability = abilities[abilityKeys[skillIndex]];
                    if (Date.now() - ability.lastUsed > ability.cooldown) {
                        ability.lastUsed = Date.now();
                        if (key === 'w') {
                            abilities.shield.active = true;
                            abilities.shield.duration = 4000;
                            setTimeout(() => {
                                abilities.shield.active = false;
                            }, 4000);
                        }
                        updateAbilityCooldowns();
                    }
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', () => {
            mouse.pressed = true;
        });
        
        canvas.addEventListener('mouseup', () => {
            mouse.pressed = false;
        });
        
        // æŒ‰é’®äº‹ä»¶
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('pause-btn').addEventListener('click', pauseGame);
        document.getElementById('reset-btn').addEventListener('click', resetGame);
        document.getElementById('devmode-btn').addEventListener('click', () => devManager.toggle());
        document.getElementById('instructions-btn').addEventListener('click', () => {
            const panel = document.getElementById('instructions-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });
        
        // æŠ€èƒ½è‡ªåŠ¨é‡Šæ”¾åˆ‡æ¢
        for (let i = 1; i <= 5; i++) {
            document.getElementById(`auto-toggle-${i}`).addEventListener('click', (e) => {
                e.stopPropagation();
                const abilityKeys = Object.keys(abilities);
                const ability = abilities[abilityKeys[i-1]];
                ability.auto = !ability.auto;
                document.getElementById(`auto-toggle-${i}`).classList.toggle('active', ability.auto);
            });
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        resetGame();
        
        // ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆåæ˜¾ç¤ºåŠ è½½å®Œæˆä¿¡æ¯
function checkImagesLoaded() {
    if (imagesLoaded === totalImages) {
        console.log('æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆï¼');
        ctx.fillStyle = "#fff";
        ctx.font = "24px Arial";
        ctx.textAlign = "center";
        ctx.fillText("KCM-æŒ–åœŸè±† 3.0  - å›¾ç‰‡å·²å…¨éƒ¨åŠ è½½", canvas.width/2, canvas.height/2 - 30);
        ctx.font = "18px Arial";
        ctx.fillText("ä½¿ç”¨ã€é“¾æ¥å†…å®¹ã€‘æä¾›çš„å›¾ç‰‡èµ„æº", canvas.width/2, canvas.height/2 + 20);
        ctx.fillText("æŒ‰ ~ é”®å¼€å¯å¼€å‘è€…æ¨¡å¼", canvas.width/2, canvas.height/2 + 50);
        
        // æ˜¾ç¤ºå›¾ç‰‡åŠ è½½ç»Ÿè®¡
        ctx.fillStyle = "#00ffaa";
        ctx.font = "16px Arial";
        ctx.fillText(`å›¾ç‰‡åŠ è½½: ${imagesLoaded}/${totalImages} å®Œæˆ`, canvas.width/2, canvas.height/2 + 80);
    } else {
        // æ˜¾ç¤ºåŠ è½½è¿›åº¦
        const progress = (imagesLoaded / totalImages) * 100;
        ctx.fillStyle = "#ffaa00";
        ctx.font = "18px Arial";
        ctx.fillText(`æ­£åœ¨åŠ è½½å›¾ç‰‡: ${Math.round(progress)}%`, canvas.width/2, canvas.height/2 + 50);
        
        // æ˜¾ç¤ºè¿›åº¦æ¡
        ctx.fillStyle = "#333333";
        ctx.fillRect(canvas.width/2 - 100, canvas.height/2 + 60, 200, 20);
        ctx.fillStyle = "#00ffff";
        ctx.fillRect(canvas.width/2 - 100, canvas.height/2 + 60, progress * 2, 20);
        
        // ç»§ç»­æ£€æŸ¥
        setTimeout(checkImagesLoaded, 100);
    }
}

// åˆå§‹æ˜¾ç¤º
ctx.fillStyle = "#050010";
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = "#fff";
ctx.font = "24px Arial";
ctx.textAlign = "center";
ctx.fillText("KCM-æŒ–åœŸè±† 3.0  - æ­£åœ¨åŠ è½½...", canvas.width/2, canvas.height/2 - 30);
ctx.font = "18px Arial";
ctx.fillText("åŸºäºã€é“¾æ¥å†…å®¹ã€‘çš„å›¾ç‰‡èµ„æºé‡æ„", canvas.width/2, canvas.height/2 + 20);

// å¼€å§‹æ£€æŸ¥å›¾ç‰‡åŠ è½½çŠ¶æ€
setTimeout(checkImagesLoaded, 100);

// æ¯å¸§æ›´æ–°æŠ€èƒ½å†·å´æ˜¾ç¤º
setInterval(updateAbilityCooldowns, 100);

// ==================== æ¸¸æˆåˆå§‹åŒ–å®Œæˆ ====================
console.log("KCM-æŒ–åœŸè±† 3.0 åˆå§‹åŒ–å®Œæˆï¼");
console.log("ä½¿ç”¨çš„å›¾ç‰‡èµ„æºï¼š");
console.log("æ™®é€šæ•Œäºº: " + enemyImages.normal.src);
console.log("å¿«é€Ÿæ•Œäºº: " + enemyImages.fast.src);
console.log("å¦å…‹æ•Œäºº: " + enemyImages.tank.src);
console.log("å½©è™¹æ•Œäºº: " + enemyImages.gay0.src);
console.log("é‡èŠ±BOSS: " + enemyImages.wildflower.src);
console.log("å½±å­BOSS: " + enemyImages.shadowT.src);
console.log("æ™®é€šBOSS: " + enemyImages.bossNormal.src);
    </script>
</body>
</html>