<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS2简化版：玩家 vs 人机KCM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: #111;
            color: #fff;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .hud {
            position: absolute;
            width: 100%;
            padding: 20px;
        }
        
        .top-hud {
            top: 0;
            display: flex;
            justify-content: space-between;
        }
        
        .health, .armor, .ammo, .kills {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 5px;
            border: 1px solid #333;
            pointer-events: all;
        }
        
        .health {
            color: #ff3333;
        }
        
        .armor {
            color: #33aaff;
        }
        
        .ammo {
            color: #ffcc00;
        }
        
        .kills {
            color: #33ff33;
        }
        
        .weapon-selector {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
            pointer-events: all;
        }
        
        .weapon {
            width: 60px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #222;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            color: #fff;
            font-size: 12px;
            text-align: center;
        }
        
        .weapon.selected {
            border-color: #ffcc00;
            background-color: #333;
        }
        
        .weapon:hover {
            background-color: #2a2a2a;
        }
        
        .center-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
        }
        
        .crosshair {
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
        }
        
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background-color: #fff;
        }
        
        .crosshair::before {
            top: 9px;
            left: 0;
            width: 20px;
            height: 2px;
        }
        
        .crosshair::after {
            top: 0;
            left: 9px;
            width: 2px;
            height: 20px;
        }
        
        .message {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 5px;
            border: 1px solid #ffcc00;
            text-align: center;
            min-width: 300px;
            display: none;
        }
        
        .message h2 {
            color: #ffcc00;
            margin-bottom: 10px;
        }
        
        .restart-btn {
            background-color: #ffcc00;
            color: #000;
            border: none;
            padding: 8px 20px;
            border-radius: 3px;
            margin-top: 10px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .restart-btn:hover {
            background-color: #ffdd33;
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #333;
            max-width: 300px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .instructions h3 {
            color: #ffcc00;
            margin-bottom: 8px;
        }
        
        .instructions li {
            margin-left: 20px;
            margin-bottom: 5px;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #ffcc00;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        
        #startScreen h1 {
            color: #ffcc00;
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }
        
        #startScreen p {
            color: #fff;
            font-size: 1.2em;
            margin-bottom: 30px;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
        }
        
        #startBtn {
            background-color: #ffcc00;
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 20px;
            transition: background-color 0.3s;
        }
        
        #startBtn:hover {
            background-color: #ffdd33;
        }
        
        #controls {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            max-width: 500px;
        }
        
        #controls h3 {
            color: #33aaff;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen">
            <h1>CS2简化版</h1>
            <p>玩家 vs 人机KCM</p>
            <div id="controls">
                <h3>操作说明</h3>
                <ul>
                    <li><strong>WASD</strong>: 前后左右移动</li>
                    <li><strong>鼠标</strong>: 视角控制</li>
                    <li><strong>左键点击</strong>: 射击/攻击</li>
                    <li><strong>R键</strong>: 换弹</li>
                    <li><strong>1-5键</strong>: 切换武器</li>
                    <li><strong>空格键</strong>: 跳跃</li>
                    <li><strong>ESC键</strong>: 退出指针锁定</li>
                </ul>
                <p><strong>目标</strong>: 击败人机KCM！</p>
            </div>
            <button id="startBtn">开始游戏</button>
        </div>
        
        <div id="ui">
            <div class="hud top-hud">
                <div class="health">生命值: <span id="healthValue">100</span></div>
                <div class="armor">护甲: <span id="armorValue">100</span></div>
                <div class="kills">击杀: <span id="killsValue">0</span></div>
                <div class="ammo">弹药: <span id="ammoValue">30</span>/<span id="ammoTotal">90</span></div>
            </div>
            
            <div class="center-crosshair">
                <div class="crosshair"></div>
            </div>
            
            <div class="weapon-selector">
                <div class="weapon selected" data-weapon="pistol">手枪</div>
                <div class="weapon" data-weapon="rifle">步枪</div>
                <div class="weapon" data-weapon="shotgun">霰弹枪</div>
                <div class="weapon" data-weapon="sniper">狙击枪</div>
                <div class="weapon" data-weapon="knife">匕首</div>
            </div>
            
            <div class="instructions">
                <h3>游戏状态</h3>
                <p>人机KCM生命值: <span id="kcmHealth">100</span></p>
                <p>当前武器: <span id="currentWeaponName">手枪</span></p>
                <p>按下ESC可退出指针锁定模式</p>
            </div>
            
            <div id="message" class="message">
                <h2 id="messageTitle">游戏结束</h2>
                <p id="messageText"></p>
                <button class="restart-btn" id="restartBtn">重新开始</button>
            </div>
        </div>
        
        <div id="loading" style="display: none;">
            <div class="loading-spinner"></div>
            <p>加载游戏中...</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // PointerLockControls 实现
        class PointerLockControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement || document.body;
                this.isLocked = false;
                
                // 欧拉角
                this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
                
                // 移动速度
                this.moveSpeed = 5.0;
                this.lookSpeed = 0.002;
                
                // 移动状态
                this.moveForward = false;
                this.moveBackward = false;
                this.moveLeft = false;
                this.moveRight = false;
                
                // 初始化
                this.init();
            }
            
            init() {
                // 添加事件监听器
                document.addEventListener('mousemove', this.onMouseMove.bind(this), false);
                document.addEventListener('pointerlockchange', this.onPointerLockChange.bind(this), false);
                document.addEventListener('mozpointerlockchange', this.onPointerLockChange.bind(this), false);
                
                // 键盘事件
                document.addEventListener('keydown', this.onKeyDown.bind(this), false);
                document.addEventListener('keyup', this.onKeyUp.bind(this), false);
                
                // 点击锁定
                this.domElement.addEventListener('click', () => {
                    if (!this.isLocked) {
                        this.lock();
                    }
                });
            }
            
            onMouseMove(event) {
                if (!this.isLocked) return;
                
                const movementX = event.movementX || event.mozMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || 0;
                
                // 更新欧拉角
                this.euler.setFromQuaternion(this.camera.quaternion);
                
                // 绕Y轴旋转（左右看）
                this.euler.y -= movementX * this.lookSpeed;
                
                // 绕X轴旋转（上下看）
                this.euler.x -= movementY * this.lookSpeed;
                
                // 限制垂直视角范围（-85度到85度）
                this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
                
                // 应用旋转
                this.camera.quaternion.setFromEuler(this.euler);
            }
            
            onPointerLockChange() {
                this.isLocked = (
                    document.pointerLockElement === this.domElement ||
                    document.mozPointerLockElement === this.domElement
                );
                
                if (this.isLocked) {
                    this.dispatchEvent({ type: 'lock' });
                } else {
                    this.dispatchEvent({ type: 'unlock' });
                }
            }
            
            onKeyDown(event) {
                if (!this.isLocked) return;
                
                switch (event.code) {
                    case 'KeyW':
                        this.moveForward = true;
                        break;
                    case 'KeyA':
                        this.moveLeft = true;
                        break;
                    case 'KeyS':
                        this.moveBackward = true;
                        break;
                    case 'KeyD':
                        this.moveRight = true;
                        break;
                }
            }
            
            onKeyUp(event) {
                switch (event.code) {
                    case 'KeyW':
                        this.moveForward = false;
                        break;
                    case 'KeyA':
                        this.moveLeft = false;
                        break;
                    case 'KeyS':
                        this.moveBackward = false;
                        break;
                    case 'KeyD':
                        this.moveRight = false;
                        break;
                }
            }
            
            lock() {
                this.domElement.requestPointerLock = this.domElement.requestPointerLock || this.domElement.mozRequestPointerLock;
                this.domElement.requestPointerLock();
            }
            
            unlock() {
                document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
                document.exitPointerLock();
            }
            
            getObject() {
                return this.camera;
            }
            
            getDirection() {
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                return direction;
            }
            
            update(delta) {
                if (!this.isLocked) return;
                
                const velocity = new THREE.Vector3();
                const direction = new THREE.Vector3();
                
                // 计算移动方向
                if (this.moveForward) direction.z -= 1;
                if (this.moveBackward) direction.z += 1;
                if (this.moveLeft) direction.x -= 1;
                if (this.moveRight) direction.x += 1;
                
                // 标准化方向向量
                if (direction.lengthSq() > 0) {
                    direction.normalize();
                }
                
                // 根据相机方向计算移动
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                
                forward.applyQuaternion(this.camera.quaternion);
                right.applyQuaternion(this.camera.quaternion);
                
                forward.y = 0;
                right.y = 0;
                forward.normalize();
                right.normalize();
                
                // 计算最终速度
                velocity.add(forward.multiplyScalar(-direction.z * this.moveSpeed * delta));
                velocity.add(right.multiplyScalar(direction.x * this.moveSpeed * delta));
                
                // 应用移动
                this.camera.position.add(velocity);
            }
            
            // 添加事件监听支持
            _listeners = {};
            
            addEventListener(type, listener) {
                if (!this._listeners[type]) {
                    this._listeners[type] = [];
                }
                this._listeners[type].push(listener);
            }
            
            removeEventListener(type, listener) {
                if (!this._listeners[type]) return;
                const index = this._listeners[type].indexOf(listener);
                if (index !== -1) {
                    this._listeners[type].splice(index, 1);
                }
            }
            
            dispatchEvent(event) {
                if (!this._listeners[event.type]) return;
                for (const listener of this._listeners[event.type]) {
                    listener(event);
                }
            }
        }
    </script>
    
    <script>
        // 游戏主逻辑
        document.addEventListener('DOMContentLoaded', function() {
            // 游戏变量
            let scene, renderer, camera, controls;
            let objects = [];
            let player, kcm;
            let velocity = new THREE.Vector3();
            let canJump = false;
            let prevTime = performance.now();
            
            // 游戏状态
            let gameState = {
                playerHealth: 100,
                playerArmor: 100,
                playerKills: 0,
                currentWeapon: 'pistol',
                ammo: {
                    pistol: { current: 30, total: 90 },
                    rifle: { current: 30, total: 90 },
                    shotgun: { current: 8, total: 24 },
                    sniper: { current: 5, total: 15 },
                    knife: { current: 1, total: 1 }
                },
                kcmHealth: 100,
                gameOver: false
            };
            
            // 武器属性
            const weapons = {
                pistol: { name: "手枪", damage: 15, range: 50, fireRate: 500 },
                rifle: { name: "步枪", damage: 20, range: 100, fireRate: 100 },
                shotgun: { name: "霰弹枪", damage: 40, range: 20, fireRate: 1000 },
                sniper: { name: "狙击枪", damage: 80, range: 200, fireRate: 1500 },
                knife: { name: "匕首", damage: 50, range: 3, fireRate: 500 }
            };
            
            let canShoot = true;
            let shootCooldown = false;
            
            // 开始游戏按钮
            document.getElementById('startBtn').addEventListener('click', startGame);
            
            // 开始游戏函数
            function startGame() {
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('loading').style.display = 'flex';
                
                // 初始化游戏
                initGame();
            }
            
            // 初始化游戏
            function initGame() {
                // 创建场景
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x222222, 1, 300);
                
                // 创建相机
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 10, 0);
                
                // 创建渲染器
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('gameContainer').appendChild(renderer.domElement);
                
                // 添加光源
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                scene.add(directionalLight);
                
                // 创建地面
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x3a7c3a, side: THREE.DoubleSide });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);
                
                // 添加网格辅助线
                const gridHelper = new THREE.GridHelper(200, 20, 0x000000, 0x000000);
                gridHelper.material.opacity = 0.2;
                gridHelper.material.transparent = true;
                scene.add(gridHelper);
                
                // 创建墙壁和障碍物
                createMap();
                
                // 创建玩家
                createPlayer();
                
                // 创建人机KCM
                createKCM();
                
                // 创建PointerLockControls
                controls = new PointerLockControls(camera, renderer.domElement);
                
                // 添加事件监听
                controls.addEventListener('lock', () => {
                    document.getElementById('loading').style.display = 'none';
                });
                
                controls.addEventListener('unlock', () => {
                    if (!gameState.gameOver) {
                        document.getElementById('startScreen').style.display = 'flex';
                    }
                });
                
                // 隐藏加载界面
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    controls.lock();
                }, 500);
                
                // 添加事件监听器
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.addEventListener('mousedown', onMouseDown);
                
                // 武器选择事件
                document.querySelectorAll('.weapon').forEach(weapon => {
                    weapon.addEventListener('click', function() {
                        if (gameState.gameOver) return;
                        
                        document.querySelectorAll('.weapon').forEach(w => w.classList.remove('selected'));
                        this.classList.add('selected');
                        
                        const weaponType = this.getAttribute('data-weapon');
                        switchWeapon(weaponType);
                    });
                });
                
                // 重新开始按钮
                document.getElementById('restartBtn').addEventListener('click', restartGame);
                
                // 窗口大小调整
                window.addEventListener('resize', onWindowResize);
                
                // 更新HUD
                updateHUD();
                
                // 开始游戏循环
                animate();
            }
            
            // 创建地图
            function createMap() {
                // 创建墙壁材质
                const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
                
                // 创建墙壁
                const walls = [
                    { pos: [0, 10, -95], size: [200, 20, 10] }, // 北墙
                    { pos: [0, 10, 95], size: [200, 20, 10] },  // 南墙
                    { pos: [-95, 10, 0], size: [10, 20, 190] }, // 西墙
                    { pos: [95, 10, 0], size: [10, 20, 190] },  // 东墙
                    
                    // 内部障碍物
                    { pos: [-40, 5, -40], size: [20, 10, 20] },
                    { pos: [40, 5, 40], size: [20, 10, 20] },
                    { pos: [-40, 5, 40], size: [20, 10, 20] },
                    { pos: [40, 5, -40], size: [20, 10, 20] },
                    { pos: [0, 5, 0], size: [30, 10, 30] }
                ];
                
                walls.forEach(wallData => {
                    const wallGeometry = new THREE.BoxGeometry(...wallData.size);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(...wallData.pos);
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    scene.add(wall);
                    objects.push(wall);
                });
                
                // 创建一些随机箱子
                const boxMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                for (let i = 0; i < 10; i++) {
                    const boxSize = Math.random() * 5 + 3;
                    const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
                    const box = new THREE.Mesh(boxGeometry, boxMaterial);
                    
                    let posX, posZ;
                    do {
                        posX = Math.random() * 160 - 80;
                        posZ = Math.random() * 160 - 80;
                    } while (Math.abs(posX) < 20 && Math.abs(posZ) < 20); // 避免放在中心区域
                    
                    box.position.set(posX, boxSize/2, posZ);
                    box.castShadow = true;
                    box.receiveShadow = true;
                    scene.add(box);
                    objects.push(box);
                }
            }
            
            // 创建玩家
            function createPlayer() {
                // 玩家由相机表示，这里只添加一个视觉表示
                const playerGeometry = new THREE.SphereGeometry(2, 16, 16);
                const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });
                player = new THREE.Mesh(playerGeometry, playerMaterial);
                player.position.y = 10;
                scene.add(player);
            }
            
            // 创建人机KCM
            function createKCM() {
                const kcmGeometry = new THREE.SphereGeometry(2, 16, 16);
                const kcmMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                kcm = new THREE.Mesh(kcmGeometry, kcmMaterial);
                kcm.position.set(50, 2, 50);
                scene.add(kcm);
                objects.push(kcm);
            }
            
            // 切换武器
            function switchWeapon(weaponType) {
                gameState.currentWeapon = weaponType;
                document.getElementById('currentWeaponName').textContent = weapons[weaponType].name;
                updateAmmoDisplay();
            }
            
            // 更新弹药显示
            function updateAmmoDisplay() {
                const weapon = gameState.currentWeapon;
                document.getElementById('ammoValue').textContent = gameState.ammo[weapon].current;
                document.getElementById('ammoTotal').textContent = gameState.ammo[weapon].total;
            }
            
            // 更新HUD
            function updateHUD() {
                document.getElementById('healthValue').textContent = gameState.playerHealth;
                document.getElementById('armorValue').textContent = gameState.playerArmor;
                document.getElementById('killsValue').textContent = gameState.playerKills;
                document.getElementById('kcmHealth').textContent = gameState.kcmHealth;
                updateAmmoDisplay();
            }
            
            // 射击
            function shoot() {
                if (gameState.gameOver || !canShoot || shootCooldown || !controls.isLocked) return;
                
                const weapon = gameState.currentWeapon;
                const ammo = gameState.ammo[weapon];
                
                if (ammo.current <= 0) {
                    // 没有弹药
                    return;
                }
                
                // 减少弹药
                ammo.current--;
                updateAmmoDisplay();
                
                // 设置射击冷却
                shootCooldown = true;
                setTimeout(() => {
                    shootCooldown = false;
                }, weapons[weapon].fireRate);
                
                // 创建射线检测是否命中
                const raycaster = new THREE.Raycaster();
                
                // 从相机位置向前发射射线
                raycaster.set(camera.position, controls.getDirection());
                
                const intersects = raycaster.intersectObjects(objects, true);
                
                if (intersects.length > 0) {
                    const target = intersects[0].object;
                    
                    // 检查是否击中了KCM
                    if (target === kcm) {
                        // 计算伤害
                        const distance = camera.position.distanceTo(kcm.position);
                        let damage = weapons[weapon].damage;
                        
                        // 距离衰减
                        if (distance > weapons[weapon].range) {
                            damage *= 0.5;
                        }
                        
                        // 应用伤害
                        gameState.kcmHealth -= damage;
                        
                        // 检查KCM是否被击败
                        if (gameState.kcmHealth <= 0) {
                            gameState.kcmHealth = 0;
                            gameState.playerKills++;
                            showMessage("胜利！", "你击败了人机KCM！");
                            gameState.gameOver = true;
                        }
                        
                        // 更新HUD
                        updateHUD();
                        
                        // 创建命中效果
                        createHitEffect(intersects[0].point);
                    }
                }
                
                // 创建枪口闪光效果
                createMuzzleFlash();
            }
            
            // 创建枪口闪光
            function createMuzzleFlash() {
                const flashLight = new THREE.PointLight(0xffff00, 2, 10);
                
                // 将闪光灯放在相机前方
                const direction = controls.getDirection().clone();
                flashLight.position.copy(camera.position).add(direction.multiplyScalar(5));
                
                scene.add(flashLight);
                
                setTimeout(() => {
                    scene.remove(flashLight);
                }, 50);
            }
            
            // 创建命中效果
            function createHitEffect(position) {
                const hitGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const hitMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const hitEffect = new THREE.Mesh(hitGeometry, hitMaterial);
                hitEffect.position.copy(position);
                scene.add(hitEffect);
                
                setTimeout(() => {
                    scene.remove(hitEffect);
                }, 200);
            }
            
            // KCM AI
            function updateKCM() {
                if (gameState.gameOver) return;
                
                // 简单AI：向玩家移动并随机射击
                const playerPos = camera.position;
                const kcmPos = kcm.position;
                
                // 计算朝向玩家的方向
                const direction = new THREE.Vector3();
                direction.subVectors(playerPos, kcmPos).normalize();
                
                // 移动KCM
                const speed = 0.05;
                kcm.position.x += direction.x * speed;
                kcm.position.z += direction.z * speed;
                
                // 确保KCM在地图范围内
                kcm.position.x = Math.max(-90, Math.min(90, kcm.position.x));
                kcm.position.z = Math.max(-90, Math.min(90, kcm.position.z));
                
                // 随机射击
                if (Math.random() < 0.005) { // 0.5%概率每帧射击
                    kcmShoot();
                }
                
                // 更新KCM朝向玩家
                kcm.lookAt(playerPos);
            }
            
            // KCM射击
            function kcmShoot() {
                if (gameState.gameOver) return;
                
                // 创建射线检测是否命中玩家
                const raycaster = new THREE.Raycaster();
                raycaster.set(kcm.position, new THREE.Vector3().subVectors(camera.position, kcm.position).normalize());
                
                const intersects = raycaster.intersectObjects([player], true);
                
                if (intersects.length > 0) {
                    // 击中玩家
                    const damage = 10 + Math.random() * 10; // 10-20伤害
                    
                    if (gameState.playerArmor > 0) {
                        gameState.playerArmor -= damage * 0.7;
                        gameState.playerHealth -= damage * 0.3;
                        
                        if (gameState.playerArmor < 0) {
                            gameState.playerHealth += gameState.playerArmor;
                            gameState.playerArmor = 0;
                        }
                    } else {
                        gameState.playerHealth -= damage;
                    }
                    
                    // 检查玩家是否死亡
                    if (gameState.playerHealth <= 0) {
                        gameState.playerHealth = 0;
                        showMessage("失败！", "你被人机KCM击败了！");
                        gameState.gameOver = true;
                    }
                    
                    // 更新HUD
                    updateHUD();
                }
            }
            
            // 显示消息
            function showMessage(title, text) {
                document.getElementById('messageTitle').textContent = title;
                document.getElementById('messageText').textContent = text;
                document.getElementById('message').style.display = 'block';
            }
            
            // 重新开始游戏
            function restartGame() {
                // 重置游戏状态
                gameState = {
                    playerHealth: 100,
                    playerArmor: 100,
                    playerKills: 0,
                    currentWeapon: 'pistol',
                    ammo: {
                        pistol: { current: 30, total: 90 },
                        rifle: { current: 30, total: 90 },
                        shotgun: { current: 8, total: 24 },
                        sniper: { current: 5, total: 15 },
                        knife: { current: 1, total: 1 }
                    },
                    kcmHealth: 100,
                    gameOver: false
                };
                
                // 重置KCM位置
                kcm.position.set(50, 2, 50);
                
                // 重置相机位置
                camera.position.set(0, 10, 0);
                camera.rotation.set(0, 0, 0);
                
                // 隐藏消息
                document.getElementById('message').style.display = 'none';
                
                // 更新HUD
                updateHUD();
                
                // 重置武器选择
                document.querySelectorAll('.weapon').forEach(w => w.classList.remove('selected'));
                document.querySelector('.weapon[data-weapon="pistol"]').classList.add('selected');
                document.getElementById('currentWeaponName').textContent = "手枪";
                
                // 重新锁定指针
                controls.lock();
            }
            
            // 键盘按下事件
            function onKeyDown(event) {
                if (!controls.isLocked) return;
                
                switch (event.code) {
                    case 'KeyW':
                        controls.moveForward = true;
                        break;
                    case 'KeyA':
                        controls.moveLeft = true;
                        break;
                    case 'KeyS':
                        controls.moveBackward = true;
                        break;
                    case 'KeyD':
                        controls.moveRight = true;
                        break;
                    case 'Space':
                        if (canJump) {
                            velocity.y = 15;
                            canJump = false;
                        }
                        break;
                    case 'KeyR':
                        reloadWeapon();
                        break;
                    case 'Digit1':
                        switchWeapon('pistol');
                        document.querySelectorAll('.weapon').forEach(w => w.classList.remove('selected'));
                        document.querySelector('.weapon[data-weapon="pistol"]').classList.add('selected');
                        break;
                    case 'Digit2':
                        switchWeapon('rifle');
                        document.querySelectorAll('.weapon').forEach(w => w.classList.remove('selected'));
                        document.querySelector('.weapon[data-weapon="rifle"]').classList.add('selected');
                        break;
                    case 'Digit3':
                        switchWeapon('shotgun');
                        document.querySelectorAll('.weapon').forEach(w => w.classList.remove('selected'));
                        document.querySelector('.weapon[data-weapon="shotgun"]').classList.add('selected');
                        break;
                    case 'Digit4':
                        switchWeapon('sniper');
                        document.querySelectorAll('.weapon').forEach(w => w.classList.remove('selected'));
                        document.querySelector('.weapon[data-weapon="sniper"]').classList.add('selected');
                        break;
                    case 'Digit5':
                        switchWeapon('knife');
                        document.querySelectorAll('.weapon').forEach(w => w.classList.remove('selected'));
                        document.querySelector('.weapon[data-weapon="knife"]').classList.add('selected');
                        break;
                }
            }
            
            // 键盘释放事件
            function onKeyUp(event) {
                if (!controls.isLocked) return;
                
                switch (event.code) {
                    case 'KeyW':
                        controls.moveForward = false;
                        break;
                    case 'KeyA':
                        controls.moveLeft = false;
                        break;
                    case 'KeyS':
                        controls.moveBackward = false;
                        break;
                    case 'KeyD':
                        controls.moveRight = false;
                        break;
                }
            }
            
            // 鼠标按下事件
            function onMouseDown(event) {
                if (event.button === 0 && controls.isLocked && !gameState.gameOver) {
                    shoot();
                }
            }
            
            // 换弹
            function reloadWeapon() {
                if (gameState.gameOver || !controls.isLocked) return;
                
                const weapon = gameState.currentWeapon;
                const ammo = gameState.ammo[weapon];
                
                if (ammo.total <= 0 || ammo.current >= 30) return;
                
                const needed = 30 - ammo.current;
                const canReload = Math.min(needed, ammo.total);
                
                ammo.current += canReload;
                ammo.total -= canReload;
                
                updateAmmoDisplay();
            }
            
            // 窗口大小调整
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // 动画循环
            function animate() {
                requestAnimationFrame(animate);
                
                const time = performance.now();
                const delta = (time - prevTime) / 1000;
                prevTime = time;
                
                if (controls.isLocked && !gameState.gameOver) {
                    // 更新控制器
                    controls.update(delta);
                    
                    // 应用重力
                    velocity.y -= 9.8 * 15.0 * delta;
                    camera.position.y += velocity.y * delta;
                    
                    // 检测玩家是否在地面上
                    if (camera.position.y < 10) {
                        velocity.y = 0;
                        camera.position.y = 10;
                        canJump = true;
                    }
                    
                    // 限制玩家在地图范围内
                    camera.position.x = Math.max(-90, Math.min(90, camera.position.x));
                    camera.position.z = Math.max(-90, Math.min(90, camera.position.z));
                    
                    // 更新玩家模型位置
                    player.position.copy(camera.position);
                    
                    // 更新KCM AI
                    updateKCM();
                }
                
                renderer.render(scene, camera);
            }
            
            // 初始化HUD
            updateHUD();
        });
    </script>
</body>
</html>